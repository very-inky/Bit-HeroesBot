SetBatchLines, -1
#SingleInstance, Force
#Persistent
#Include Debug.ahk
#Include FindText.ahk
#Include Patterns.ahk
;Soundbeep, 500, 600
;──────────────────────────────────────────────────────────────
; Context‐object refactor of your BitHeroesBot
; All OCR patterns come from PatternBot.ahk via the global `Patterns` object.
;──────────────────────────────────────────────────────────────

;——— Build the Bot “context” object —————————————————————————————
global Bot := {}

; 1) Action configurations & rotation
Bot.actionConfig := { Quest: true, PVP: true, WorldBoss: true
                  , Raid: true, Trials: true, Expedition: true, Gauntlet: true }
Bot.actionOrder := ["Quest","PVP","WorldBoss","Raid","Trials","Expedition","Gauntlet"]
Bot.currentActionIndex := 2 ; starting with index 4 for Raid testing

; 2) Questing configs
; --- Define the specific Zone PATTERNS and Dungeon NAMES you want to run ---
Bot.desiredZones       := [ Patterns.Zone[3], Patterns.Zone[2] ] ; Use the PATTERN for Zone 3 from Patterns.ahk
Bot.desiredDungeons    := [ "Dungeon2", "Dungeon1" ]       ;  Not all zones have 3 dungeons!
; --- If running multiple configurations, add more pairs!

Bot.currentSelectionIndex := 1

; 3) PVP configs
Bot.PvpTicketChoice   := 5    ; 1–5
Bot.PvpOpponentChoice := 2    ; 1–4

Bot.Raid := {}
Bot.Raid.Conf := {}
; 4) Raid configs
Bot.Raid.Conf.List := ["Raid6", "Raid4"] ; List of raids to run. (MATCH THESE TO Patterns.Raid.RaidName
Bot.Raid.Conf.Count := 0 ; Number of raids to run, (0 for infinite, run raids till out of resources.)
Bot.Raid.Conf.Difficulty := "Heroic" ; Raid difficulty (Normal, Hard, Heroic)
Bot.Raid.Conf.CurrentIndex := 1 ; Tracks which raid in the list to run next
Bot.Raid.Conf.CompletedCount := 0 ; Tracks how many raids have been completed in this session/cycle

; 5) OCR patterns
Bot.ocr := Patterns       ; so we can do e.g. Bot.ocr.QuestIcon, Bot.ocr.Zone[1], etc.

; 6) State & cooldown tracking
Bot.gameState     := "NotLoggedIn"
Bot.actionCooldown := 1200000  ; 20 min in ms
DebugLog("=== BOT LOADED; initial gameState=" Bot.gameState)
Bot.lastActionTime := {}
for idx, act in Bot.actionOrder
    Bot.lastActionTime[act] := 0

;———————————————————————————————————————————————————————————————
; Kick off the main loop
SetTimer, BotMain, 1000
return

;———————————————————————————————————————————————————————————————
BotMain:
    global Bot

    if (Bot.gameState = "Paused")
        return

    ; === NotLoggedIn ===
    if (Bot.gameState = "NotLoggedIn") {
        DebugLog("NotLoggedIn: looking for quest icon")
        if (IsMainScreenAnchor()) {
            Bot.gameState := "NormalOperation"
            DebugLog("→ NormalOperation")
        } else {
            AttemptReconnect()
            Bot.gameState := "HandlingPopups"
            ; No need to DebugLog state change here, HandlingPopups will log entry
        }
        return
    }

    ; === HandlingPopups ===
    if (Bot.gameState = "HandlingPopups") {
        DebugLog("HandlingPopups: clearing pop‑ups")
        popupAttempts := 0
        ; Loop until main screen anchor is found OR attempts run out
        while (!IsMainScreenAnchor() and popupAttempts < 7) {
            Send, {Esc}
            Sleep, 500
            popupAttempts++
            if (IsDisconnected()) {
                AttemptReconnect() ; This function should have its own logs
                Sleep, 2000
            }
            ; Check anchor again inside loop for faster exit if Esc worked quickly
            if (IsMainScreenAnchor()) {
                DebugLog("HandlingPopups: Main screen anchor found during popup clearing.")
                break ; Exit the while loop early
            }
        }
        ; After loop, determine next state based on whether anchor was found
        finalAnchorCheck := IsMainScreenAnchor()
        nextState := finalAnchorCheck ? "NormalOperation" : "NotLoggedIn"
        DebugLog("HandlingPopups: Finished attempts. Anchor found: " . (finalAnchorCheck ? "Yes" : "No") . ". → " . nextState)
        Bot.gameState := nextState
        return
    }

    ; === NormalOperation ===
    if (Bot.gameState = "NormalOperation") {
        current := Bot.actionOrder[Bot.currentActionIndex]
        now := A_TickCount

        ; skip if disabled in config
        if (! Bot.actionConfig[current]) {
            DebugLog("NormalOperation: Skipping " . current . " (disabled in config)")
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
            return
        }

        ; cooldown check
        if ((now - Bot.lastActionTime[current]) >= Bot.actionCooldown) {
            DebugLog("NormalOperation: Running " . current . " (cooldown ready)")
            result := ""

            ; --- Raid Count Check (Specific for Raid) ---
            if (current = "Raid" && Bot.Raid.Conf.Count > 0 && Bot.Raid.Conf.CompletedCount >= Bot.Raid.Conf.Count) {
                 DebugLog("NormalOperation: Skipping Raid - Target count (" . Bot.Raid.Conf.Count . ") already reached.")
                 Bot.lastActionTime[current] := now ; Update cooldown time even if skipped due to count
                 Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
                 return ; Skip to next action
            }
            ; --- End Raid Count Check ---

            Switch current
            {
                Case "Quest":      result := ActionQuest()
                Case "PVP":        result := ActionPVP()
                Case "WorldBoss":  result := ActionWorldBoss()
                Case "Raid":       result := ActionRaid()
                Case "Trials":     result := ActionTrials()
                Case "Expedition": result := ActionExpedition()
                Case "Gauntlet":   result := ActionGauntlet()
                Default:
                    DebugLog("NormalOperation: ERROR - Unknown action '" . current . "'")
                    result := "error_unknown_action"
            }

            ; --- Process action result ---
            DebugLog("BotMain: Action '" . current . "' returned: '" . result . "'") ; Log result

            if (result = "started") {
                Bot.gameState := "ActionRunning"
                DebugLog("BotMain: " . current . " → ActionRunning")
            }
            else if (result = "outofresource") {
                DebugLog("BotMain: '" . current . "' reported 'outofresource'. Setting cooldown and returning to HandlingPopups state.")
                ; No need to call ClosePopup() here - HandlingPopups state will send Esc.

                ; Set the cooldown for the action that failed
                Bot.lastActionTime[current] := now
                DebugLog("BotMain: Cooldown set for " . current)
                Loop, 4
                {
                    Send, {esc}
                    Sleep 600
                }
                ; --- Change state to force UI reset via HandlingPopups logic ---
                Bot.gameState := "HandlingPopups"
                DebugLog("BotMain: State changed to HandlingPopups to ensure return to main screen.")

                ; DO NOT advance Bot.currentActionIndex here. Let HandlingPopups resolve first.
            }
            else if (result = "disconnected") {
                Bot.gameState := "NotLoggedIn"
                ; No DebugLog needed here, NotLoggedIn state handles its entry log
            }
            else if (current = "PVP" and result = "success") { ; Note: PVP returns "started", not "success" now
                ; loop PVP immediately - do nothing here, next loop iteration will handle it
                 DebugLog("BotMain: PVP returned success, looping PVP immediately.")
            }
            else {
                ; Default case for other results ("retry", "success" for non-PVP/non-Raid, "error", etc.)
                ; Start cooldown & advance to next action
                 DebugLog("BotMain: Action '" . current . "' finished with result '" . result . "'. Starting cooldown and advancing.")
                Bot.lastActionTime[current] := now
                Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
            }
        } else {
            ; skip due to cooldown
            DebugLog("NormalOperation: Skipping " . current . " (on cooldown)")
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
        }
        return
    }

  ; === ActionRunning ===
    if (Bot.gameState = "ActionRunning") {
        current := Bot.actionOrder[Bot.currentActionIndex]
        DebugLog("ActionRunning: monitoring " . current)
        monitorResult := ""

        ; Call the appropriate monitoring function based on the current action
        Switch current
        {
            Case "Quest": monitorResult := MonitorQuestProgress()
            Case "PVP":   monitorResult := MonitorPVPProgress()
            Case "Raid":  monitorResult := MonitorRaidProgress() ; Ensure this function name matches yours
            Default:
                ; No monitor needed for simple actions (WorldBoss, Trials, etc.)
                DebugLog("ActionRunning: No monitor function for '" . current . "'. Returning to NormalOperation.")
                Bot.gameState := "NormalOperation"
                Bot.lastActionTime[current] := A_TickCount
                Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
                DebugLog("ActionRunning: Cooldown set for " . current . ", index advanced.")
                return
        }

        DebugLog("ActionRunning: Monitor function for '" . current . "' returned: '" . monitorResult . "'")

        ; --- Process monitor result ---
        if (monitorResult = "pvp_completed_continue") {
            DebugLog("ActionRunning: PVP monitor reported completion. Returning to NormalOperation.")
            Bot.gameState := "NormalOperation"
            return
        }
        else if (monitorResult = "raid_completed" or monitorResult = "raid_completed_next") { ; Check for EITHER raid complete result
            DebugLog("ActionRunning: Raid monitor reported completion.")
            Bot.Raid.Conf.CompletedCount += 1
            Bot.Raid.Conf.CurrentIndex += 1
            if (Bot.Raid.Conf.CurrentIndex > Bot.Raid.Conf.List.MaxIndex()) { ; Use MaxIndex here
                Bot.Raid.Conf.CurrentIndex := 1 ; Wrap around
            }
            DebugLog("ActionRunning: Raid count incremented to " . Bot.Raid.Conf.CompletedCount . ". Next Raid index: " . Bot.Raid.Conf.CurrentIndex)

            ; Check if target count reached (only if count > 0)
            if (Bot.Raid.Conf.Count > 0 && Bot.Raid.Conf.CompletedCount >= Bot.Raid.Conf.Count) {
                DebugLog("ActionRunning: Raid target count (" . Bot.Raid.Conf.Count . ") reached.")
                Bot.lastActionTime[current] := A_TickCount ; Set cooldown
                Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1 ; Advance past Raid
                DebugLog("ActionRunning: Cooldown set for Raid, index advanced.")
                Bot.gameState := "NormalOperation" ; Return to NormalOperation
                DebugLog("ActionRunning: Returning to NormalOperation.")
                return ; !!! Important: Return after handling state change
            } else {
                DebugLog("ActionRunning: Raid target count not reached or infinite. Cooldown NOT set, index NOT advanced (will attempt next raid).")
                Bot.gameState := "HandlingPopups" ; Go back via popups to restart Raid action
                DebugLog("ActionRunning: State changed to HandlingPopups to ensure return to main screen before next raid attempt.")
                return ; !!! Important: Return after handling state change
            }

        }
        else if (monitorResult = "raid_rerun") { ; Handle specific rerun case for single-config raid
             DebugLog("ActionRunning: Monitor reported 'raid_rerun'. Raid is restarting. Remaining in ActionRunning.")
             ; Do nothing, stay in ActionRunning state
             return
        }
        else if (monitorResult = "outofresource") {
            DebugLog("ActionRunning: Monitor reported 'outofresource' for " . current . ".")
            Bot.lastActionTime[current] := A_TickCount ; Set cooldown
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1 ; Advance past current action
            Bot.gameState := "HandlingPopups" ; Go handle popups first
            DebugLog("ActionRunning: Cooldown set for " . current . ", index advanced. State changed to HandlingPopups.")
            return
        }
        else if (monitorResult = "disconnected" or monitorResult = "player_dead") {
             DebugLog("ActionRunning: Monitor reported '" . monitorResult . "'. State already changed by monitor function.")
             ; Monitor function should have already changed Bot.gameState to NotLoggedIn
             return
         }
        else if (monitorResult = "error") {
             DebugLog("ActionRunning: Monitor reported 'error'. Setting cooldown and advancing past " . current . ".")
             Bot.lastActionTime[current] := A_TickCount
             Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
             Bot.gameState := "HandlingPopups" ; Go to popups after error for safety
             DebugLog("ActionRunning: State changed to HandlingPopups after error.")
             return
        }
        else if (monitorResult = "start_next_config") { ; Quest specific
            DebugLog("ActionRunning: Monitor reported quest config complete. Advancing config index.")
            Bot.currentSelectionIndex += 1
            if (Bot.currentSelectionIndex > Bot.desiredZones.MaxIndex()) {
                DebugLog("ActionRunning: All quest configs completed. Resetting config index.")
                Bot.currentSelectionIndex := 1
                Bot.lastActionTime[current] := A_TickCount
                Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
                DebugLog("ActionRunning: Cooldown set for Quest, index advanced.")
                Bot.gameState := "NormalOperation"
            } else {
                DebugLog("ActionRunning: Moving to next quest config (Index: " . Bot.currentSelectionIndex . "). Returning to NormalOperation to start it.")
                Bot.gameState := "NormalOperation"
            }
            return
        }
        else if (monitorResult = "rerun") { ; Specific to single-config Quest monitor
             DebugLog("ActionRunning: Monitor reported 'rerun'. Quest is restarting. Remaining in ActionRunning.")
             return
         }

        ; Default case includes "in_progress" - stay in ActionRunning state
        ; No action needed, just wait for the next timer tick
        return
    }
     
;———————————————————————————————————————————————————————————————
; === Quest Flow ===
ActionQuest() {
    global Bot
    DebugLog("ActionQuest: --- Entered function ---")

    ; Check if Quest window is open
    questWinOpen := IsQuestWindowOpen()
    DebugLog("ActionQuest: IsQuestWindowOpen returned: '" . (questWinOpen ? "True" : "False") . "'")

    if (!questWinOpen) {
        DebugLog("ActionQuest: Quest window NOT open, attempting ClickQuestIcon()")
        ClickQuestIcon() ; Assumes this function has its own logs
        Sleep, 600 ; Wait for window to potentially open
        questWinOpen := IsQuestWindowOpen() ; Check again
        DebugLog("ActionQuest: IsQuestWindowOpen (after click) returned: '" . (questWinOpen ? "True" : "False") . "'")
        if (!questWinOpen) {
            DebugLog("ActionQuest: Failed to open quest window after click. Returning 'retry'.")
            return "retry"
        }
    } else {
         DebugLog("ActionQuest: Quest window was already open.")
    }

    ; Get desired targets for this run
    targetZonePattern := Bot.desiredZones[Bot.currentSelectionIndex]
    targetDungeonName := Bot.desiredDungeons[Bot.currentSelectionIndex]
    DebugLog("ActionQuest: Target Zone Pattern starts: " . SubStr(targetZonePattern, 1, 10) . "..., Target Dungeon Name: " . targetDungeonName)

    ; Ensure the correct zone is displayed
    DebugLog("ActionQuest: Calling EnsureCorrectZone(...)")
    zoneCorrect := EnsureCorrectZone(targetZonePattern) ; Pass the PATTERN
    DebugLog("ActionQuest: EnsureCorrectZone returned: '" . zoneCorrect . "'")
    if (!zoneCorrect) {
        DebugLog("ActionQuest: EnsureCorrectZone failed. Returning 'retry'.")
        return "retry"
    }

    ; Get the name of the currently displayed zone (should match target now)
    currentZoneName := DetectCurrentZoneName()
    DebugLog("ActionQuest: Current confirmed zone name for dungeon check: " . currentZoneName)

    ; Check if the desired dungeon pattern is visible
    DebugLog("ActionQuest: Calling EnsureCorrectDungeon(" . currentZoneName . ", " . targetDungeonName . ") to check presence.")
    dungeonPresent := EnsureCorrectDungeon(currentZoneName, targetDungeonName) ; Gets result OBJECT (evaluates true/false)
    DebugLog("ActionQuest: EnsureCorrectDungeon (presence check) returned: '" . (dungeonPresent ? "Object (True)" : "0 (False)") . "'")

    if (!dungeonPresent) { ; Check if the dungeon pattern was found
        DebugLog("ActionQuest: EnsureCorrectDungeon failed (pattern not found). Returning 'retry'.")
        return "retry"
    } else {
        ; Dungeon pattern IS present. Now FIND IT AGAIN to update Global X/Y and CLICK.
        DebugLog("ActionQuest: Dungeon pattern found by check. Finding again to click...")

        ; Retrieve the pattern string again (needed for the local FindText call)
        ; Error handling for invalid zone/dungeon index happens within this block now
        if (!Bot.ocr.DungeonMapping.HasKey(currentZoneName)) {
             DebugLog("ActionQuest: ERROR - Zone '" . currentZoneName . "' not found in DungeonMapping for find-and-click.")
             return "retry"
        }
        dungeonPatternList := Bot.ocr.DungeonMapping[currentZoneName]
        dungeonIndex := SubStr(targetDungeonName, 8)
        if (dungeonIndex is not number or dungeonIndex < 1 || dungeonIndex > dungeonPatternList.MaxIndex()) {
            DebugLog("ActionQuest: ERROR - Invalid dungeon index '" . dungeonIndex . "' for find-and-click.")
            return "retry"
        }
        targetDungeonPattern := dungeonPatternList[dungeonIndex]

        ; Perform FindText AGAIN, this time using X, Y output vars to update globals
        if (FindText(X, Y, 660, 496, 2501, 1680, 0, 0, targetDungeonPattern)) {
             DebugLog("ActionQuest: Found dungeon again- Clicking")
             ; Use the standard click method which relies on the X,Y updated above
             FindText().Click(X, Y, "L")
             Sleep, 900 ; Increased delay after clicking dungeon
        } else {
             DebugLog("ActionQuest: ERROR - Failed to find dungeon pattern for click immediately after check found it!? Returning 'retry'.")
             return "retry" ; Should not happen if EnsureCorrectDungeon just worked, but safety check.
        }
    }

    ; Select Heroic Difficulty
    DebugLog("ActionQuest: Calling SelectHeroic()")
    heroicSelected := SelectHeroic() ; Assumes this function has own logs
    DebugLog("ActionQuest: SelectHeroic returned: '" . heroicSelected . "'")
    if (!heroicSelected) {
         DebugLog("ActionQuest: SelectHeroic failed. Returning 'retry'.")
        return "retry"
    }

    ; Click the final Accept button (which checks for resources)
    DebugLog("ActionQuest: Calling ClickAcceptQuest()")
    acceptResult := ClickAcceptQuest() ; Assumes this function has own logs
    DebugLog("ActionQuest: ClickAcceptQuest returned: '" . acceptResult . "'")

    if (acceptResult = "outofresource") {
         DebugLog("ActionQuest: Detected out of resources. Returning 'outofresource'.")
        return "outofresource"
    }
    if (acceptResult != "confirmed") {
        DebugLog("ActionQuest: ClickAcceptQuest returned unexpected value '" . acceptResult . "'. Returning 'retry'.")
        return "retry"
    }

    ; --- Quest Start Confirmed - Perform one-time AutoPilot check ---
    DebugLog("ActionQuest: Quest accepted. Waiting for quest screen to load before AutoPilot check...")
    Sleep, 1500 ; Wait 1.5 seconds (Adjust as needed)

    DebugLog("ActionQuest: Performing one-time AutoPilot check.")
    autoPilotOk := EnsureAutoPilotOn() ; Assumes this function has own logs
    if (!autoPilotOk) {
        DebugLog("ActionQuest: Warning - EnsureAutoPilotOn failed after starting quest.")
        ; Continue anyway, AutoPilot isn't critical for starting
    } else {
         DebugLog("ActionQuest: EnsureAutoPilotOn completed successfully (check its logs for details).")
    }
    ; --- End AutoPilot Check ---

    DebugLog("ActionQuest: --- Success! All steps completed. Returning 'started'. ---")
    return "started"
}
MonitorQuestProgress() {
    global Bot
    ; Note: No AutoPilot check here anymore.

    if (IsActionComplete()) {
        DebugLog("MonitorQuestProgress: IsActionComplete returned True.")
        if (Bot.desiredZones.Length() = 1) {
            DebugLog("MonitorQuestProgress: Single config - attempting Rerun.")
            ClickRerun()
            Sleep, 1200
            outOfRes := CheckOutOfResources()
            returnVal := outOfRes ? "outofresource" : "rerun"
            DebugLog("MonitorQuestProgress: Rerun attempt finished. Returning '" . returnVal . "'")
            return returnVal
        } else {
            DebugLog("MonitorQuestProgress: Multi-config - attempting ClickTownOnComplete.")
            if (ClickTownOnComplete()) {
                Sleep, 1000
                DebugLog("MonitorQuestProgress: ClickTownOnComplete succeeded. Returning 'start_next_config'")
                return "start_next_config"
            }
            DebugLog("MonitorQuestProgress: ClickTownOnComplete failed. Returning 'error'")
            return "error"
        }
    }
    ; If action is not complete, check for other states:
    if (IsDisconnected()) {
        DebugLog("MonitorQuestProgress: IsDisconnected returned True.")
        AttemptReconnect()
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorQuestProgress: State changed to NotLoggedIn. Returning 'disconnected'")
        return "disconnected"
    }
    if (IsPlayerDead()) {
        DebugLog("MonitorQuestProgress: IsPlayerDead returned True.")
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorQuestProgress: State changed to NotLoggedIn. Returning 'player_dead'")
        return "player_dead"
    }

    dialogueHandled := HandleInProgressDialogue()
    if (dialogueHandled) {
        DebugLog("MonitorQuestProgress: Handled in-progress dialogue.")
    }

    return "in_progress"
}

;———————————————————————————————————————————————————————————————
; === PVP Flow ===
ActionPVP() {
    global Bot ; Only Bot needed globally here
    DebugLog("ActionPVP: --- Entered function ---")

    opponentsVisibleResult := OpponentsVisible() ; Assumes this helper has debug logs
    DebugLog("ActionPVP: Initial OpponentsVisible check returned: '" . (opponentsVisibleResult ? "True" : "False") . "'")

    if (!opponentsVisibleResult) {
        ; Need to navigate to opponent screen
        DebugLog("ActionPVP: Opponents not visible. Navigating PVP menu...")

        pvpWindowOpen := IsPvpWindowOpen() ; Assumes this helper has debug logs
        DebugLog("ActionPVP: IsPvpWindowOpen returned: '" . (pvpWindowOpen ? "True" : "False") . "'")
        if (!pvpWindowOpen) {
            DebugLog("ActionPVP: PVP Window not open. Calling ClickPVPButton...")
            if (!ClickPVPButton()) { ; Assumes this helper logs failure and returns false
                 DebugLog("ActionPVP: ClickPVPButton failed. Returning 'retry'.")
                 return "retry"
            }
            Sleep, 600 ; Wait for window to open
             pvpWindowOpen := IsPvpWindowOpen() ; Check again
             DebugLog("ActionPVP: IsPvpWindowOpen (after click) returned: '" . (pvpWindowOpen ? "True" : "False") . "'")
             if (!pvpWindowOpen) {
                  DebugLog("ActionPVP: PVP Window still not open after click. Returning 'retry'.")
                  return "retry"
             }
             DebugLog("ActionPVP: PVP Window successfully opened.")
        } else {
             DebugLog("ActionPVP: PVP Window was already open.")
        }


        DebugLog("ActionPVP: Calling EnsureCorrectTickets(Choice: " . Bot.PvpTicketChoice . ")")
        ticketsCorrect := EnsureCorrectTickets(Bot.PvpTicketChoice) ; Assumes this helper has debug logs
         DebugLog("ActionPVP: EnsureCorrectTickets returned: '" . (ticketsCorrect ? "True" : "False") . "'")
        if (!ticketsCorrect) {
            DebugLog("ActionPVP: EnsureCorrectTickets failed. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: Tickets confirmed correct.")


        DebugLog("ActionPVP: Calling ClickPvpPlay...")
        if (!ClickPvpPlay()) { ; Assumes this helper logs failure and returns false
            DebugLog("ActionPVP: ClickPvpPlay failed. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: ClickPvpPlay succeeded.")
        Sleep, 1000 ; Wait after clicking play


        DebugLog("ActionPVP: Calling CheckOutOfResources...")
        if (CheckOutOfResources()) { ; Assumes this helper has debug logs
            DebugLog("ActionPVP: Out of resources detected after clicking Play. Returning 'outofresource'.")
            return "outofresource"
        }
        DebugLog("ActionPVP: No 'Out Of Resources' detected after clicking Play.")


        ; Re-check if opponents are visible now after clicking Play
        opponentsVisibleResult := OpponentsVisible()
        DebugLog("ActionPVP: OpponentsVisible (after Play) returned: '" . (opponentsVisibleResult ? "True" : "False") . "'")
        if (!opponentsVisibleResult) {
            DebugLog("ActionPVP: Opponents still not visible after clicking Play. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: Opponent screen successfully reached.")

    } else {
         DebugLog("ActionPVP: Opponents were already visible.")
    }

    ; --- Opponents should be visible at this point ---

    DebugLog("ActionPVP: Calling SelectPvpOpponent (Choice: " . Bot.PvpOpponentChoice . ")")
    opponentSelected := SelectPvpOpponent(Bot.PvpOpponentChoice) ; Assumes this helper has debug logs
    DebugLog("ActionPVP: SelectPvpOpponent returned: '" . (opponentSelected ? "True" : "False") . "'")
    if (!opponentSelected) {
        DebugLog("ActionPVP: SelectPvpOpponent failed. Returning 'retry'.")
        return "retry"
    }
     DebugLog("ActionPVP: Opponent selected.")


    Sleep, 500 ; Wait after selecting opponent


    DebugLog("ActionPVP: Calling ClickPvpAccept...")
    accepted := ClickPvpAccept() ; Assumes this helper has debug logs
    DebugLog("ActionPVP: ClickPvpAccept returned: '" . (accepted ? "True" : "False") . "'")
    if (!accepted) {
         DebugLog("ActionPVP: ClickPvpAccept failed. Returning 'retry'.")
        return "retry"
    }
    DebugLog("ActionPVP: PVP Accept clicked.")

    DebugLog("ActionPVP: Performing one-time AutoPilot check.")
    autoPilotOk := EnsureAutoPilotOn() ; Assumes this function has own logs
    if (!autoPilotOk) {
        DebugLog("ActionPVP: Warning - EnsureAutoPilotOn failed after starting")
        ; Continue anyway, AutoPilot isn't critical for starting
    } else {
         DebugLog("ActionPVP: EnsureAutoPilotOn completed successfully (check its logs for details).")
    }


    DebugLog("ActionPVP: --- Success! All steps completed. Returning 'started'. ---")
    return "started"
}

MonitorPVPProgress() {
    global Bot
    ; Note: BotMain logs "monitoring PVP"

    actionComplete := IsActionComplete() ; Checks for Town button
    DebugLog("MonitorPVPProgress: IsActionComplete returned: '" . (actionComplete ? "True" : "False") . "'")
    if (actionComplete) {
        DebugLog("MonitorPVPProgress: PVP Complete detected. Attempting ClickTownOnComplete.")
        townClicked := ClickTownOnComplete() ; Tries to click Town button
        DebugLog("MonitorPVPProgress: ClickTownOnComplete returned: '" . (townClicked ? "True" : "False") . "'")
        if (townClicked) {
            Sleep, 800
            DebugLog("MonitorPVPProgress: Successfully clicked Town. Returning 'pvp_completed_continue'")
            return "pvp_completed_continue" ; Signal BotMain to go back to NormalOperation to loop PVP
        } else {
            DebugLog("MonitorPVPProgress: ClickTownOnComplete FAILED. Returning 'error'")
            return "error" ; Failed to click town button
        }
    }

    ; If action is not complete, check for other states:
    disconnected := IsDisconnected()
    DebugLog("MonitorPVPProgress: IsDisconnected returned: '" . (disconnected ? "True" : "False") . "'")
    if (disconnected) {
        DebugLog("MonitorPVPProgress: Disconnected detected.")
        AttemptReconnect() ; Assumes this function logs its actions
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorPVPProgress: State changed to NotLoggedIn. Returning 'disconnected'")
        return "disconnected"
    }

    playerDead := IsPlayerDead()
    DebugLog("MonitorPVPProgress: IsPlayerDead returned: '" . (playerDead ? "True" : "False") . "'")
    if (playerDead) {
        DebugLog("MonitorPVPProgress: Player Dead detected.")
        DebugLog("MonitorPVPProgress: Sending Esc to clear death screen (if possible).")
        Send, {Esc} ; Try to dismiss death screen
        Sleep, 800
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorPVPProgress: State changed to NotLoggedIn. Returning 'player_dead'")
        return "player_dead"
    }

    ; No dialogue check needed for PVP unless specified otherwise.

    ; If we reach here, the PVP match is still running normally
    DebugLog("MonitorPVPProgress: No end/fail state detected. Returning 'in_progress'")
    return "in_progress"
}

;———————————————————————————————————————————————————————————————
; === Stub flows for other actions ===
ActionWorldBoss()   {
    global Bot
    DebugLog("ActionWorldBoss: --- Entered function ---")
    ; Add logic to find and click World Boss button
    ; Add logic to click attack/accept
    ; Check for resources if applicable before starting
    if (CheckOutOfResources()) {
        DebugLog("ActionWorldBoss: Out of resources detected. Returning 'outofresource'.")
        return "outofresource"
    }
    DebugLog("ActionWorldBoss: --- Success! Returning 'success'. ---")
    return "success"
}


ActionRaid() {
    global Bot
    DebugLog("ActionRaid: --- Entered function ---")

    ; --- Check Configuration ---
    isObj := IsObject(Bot.Raid.Conf.List)
    maxIdx := ""
    if (isObj) {
            maxIdx := Bot.Raid.Conf.List.MaxIndex() 
               }
    DebugLog("ActionRaid: Config Check - IsObject(Bot.Raid.Conf.List) = " . isObj . ", Bot.Raid.Conf.List.MaxIndex() = " . maxIdx)
    if (!isObj || maxIdx = "" || maxIdx = 0) {
        DebugLog("ActionRaid: ERROR - Failed config check. No raids defined in Bot.Raid.Conf.List. Returning 'error'.")
        return "error"
    }
    if (Bot.Raid.Conf.CurrentIndex < 1 || Bot.Raid.Conf.CurrentIndex > Bot.Raid.Conf.List.MaxIndex()) {
        DebugLog("ActionRaid: Warning - Invalid Bot.Raid.Conf.CurrentIndex. Resetting to 1.")
        Bot.Raid.Conf.CurrentIndex := 1
    }

    ; --- Determine Target Raid ---
    configListIndex := Bot.Raid.Conf.CurrentIndex
    targetRaidName := Bot.Raid.Conf.List[configListIndex] ; Get the NAME (e.g., "Raid2")
    targetDifficulty := Bot.Raid.Conf.Difficulty

    ; *** NEW: Extract the numeric index FROM the NAME ***
    targetMappingIndex := SubStr(targetRaidName, 5) ; Extract number part (assumes format "RaidN")
    if (targetMappingIndex is not number or targetMappingIndex < 1) {
        DebugLog("ActionRaid: ERROR - Could not extract valid numeric index from raid name '" . targetRaidName . "'. Returning 'error'.")
        return "error"
    }
    ; Convert to integer just in case
    targetMappingIndex += 0 
    
    DebugLog("ActionRaid: Config List Index: " . configListIndex . ", Target Raid Name: '" . targetRaidName . "', Target Mapping Index: " . targetMappingIndex . ", Difficulty: '" . targetDifficulty . "'")


    ; --- Navigation ---
    DebugLog("ActionRaid: Checking if Raid window is open...")
    if (!IsRaidWindowOpen()) {
        DebugLog("ActionRaid: Raid window not open. Clicking Raid icon...")
        if (!ClickRaidIcon()) {
            DebugLog("ActionRaid: ClickRaidIcon failed. Returning 'retry'.")
            return "retry"
        }
        Sleep, 900
        if (!IsRaidWindowOpen()) {
            DebugLog("ActionRaid: Raid window did not appear after clicking icon. Returning 'retry'.")
            return "retry"
        }
        DebugLog("ActionRaid: Raid window opened.")
    } else {
        DebugLog("ActionRaid: Raid window already open.")
    }

    ; --- Select Raid (Using Correct Target Index) ---
    ; *** Call the helper using the correct MAPPING INDEX ***
    DebugLog("ActionRaid: Ensuring correct raid (Mapping Index: " . targetMappingIndex . ") is selected...")
    if (!EnsureCorrectRaidSelected(targetMappingIndex)) {
        DebugLog("ActionRaid: EnsureCorrectRaidSelected failed for index '" . targetMappingIndex . "'. Returning 'retry'.")
        return "retry"
    }
    DebugLog("ActionRaid: Successfully ensured raid index '" . targetMappingIndex . "' is selected.")
    Sleep, 500

    ; --- Click SUMMON Button ---
    DebugLog("ActionRaid: Clicking Raid Summon button...")
    if (!ClickRaidSummonButton()) {
        DebugLog("ActionRaid: ClickRaidSummonButton failed. Returning 'retry'.")
        return "retry"
    }
     DebugLog("ActionRaid: Clicked Raid Summon button.")
    Sleep, 1000

 ; --- *** NEW: Handle Pre-Raid Dialogue (Looping) *** ---
    DebugLog("ActionRaid: Checking for pre-raid dialogue...")
    dialogueAttempts := 0
    maxDialogueAttempts := 9 ; Try up to 5 times to close dialogue
    Loop, %maxDialogueAttempts%
    {
        dialogueFound := ClickPreRaidDialogue()
        if (!dialogueFound) { ; Dialogue is not present
            if (A_Index = 1) { ; Dialogue wasn't found on the very first check
                 DebugLog("ActionRaid: No pre-raid dialogue detected.")
            } else { ; Dialogue was found previously but is now gone
                 DebugLog("ActionRaid: Dialogue successfully closed after " . (A_Index - 1) . " attempt(s).")
            }
            break ; Exit the dialogue handling loop
        }
        ; If dialogue WAS found...
        DebugLog("ActionRaid: Dialogue found (Attempt " . A_Index . "). Esc sent by handler. Waiting...")
        Sleep, 750 ; Wait longer for Esc to take effect before checking again
    }

    ; Check if the loop finished because dialogue is gone, or because attempts ran out
    if (dialogueFound) { ; If dialogueFound is still true, the loop finished without breaking
        DebugLog("ActionRaid: ERROR - Dialogue still present after " . maxDialogueAttempts . " attempts! Returning 'retry'.")
        return "retry"
    }
    
    ; --- Select Difficulty ---
    DebugLog("ActionRaid: Selecting Difficulty '" . targetDifficulty . "'...")
    if (!SelectRaidDifficulty(targetDifficulty)) {
        DebugLog("ActionRaid: SelectRaidDifficulty failed for '" . targetDifficulty . "'. Returning 'retry'.")
        return "retry"
    }
    DebugLog("ActionRaid: Successfully selected difficulty '" . targetDifficulty . "'.")
    Sleep, 700

    ; --- Start Raid (Click Play Button) ---
    DebugLog("ActionRaid: Clicking Play button...")
    if (!ClickRaidPlayButton()) {
        DebugLog("ActionRaid: ClickRaidPlayButton failed. Returning 'retry'.")
        return "retry"
    }
    DebugLog("ActionRaid: Clicked Play button.")
    Sleep, 1000

    ; --- Check Resources ---
    if (CheckOutOfResources()) {
        DebugLog("ActionRaid: Out of resources detected after clicking Play. Returning 'outofresource'.")
        return "outofresource"
    }
    DebugLog("ActionRaid: No 'Out Of Resources' detected after clicking Play.")

    DebugLog("ActionRaid: Performing one-time AutoPilot check.")
    autoPilotOk := EnsureAutoPilotOn() ; Assumes this function has own logs
    if (!autoPilotOk) {
        DebugLog("ActionRaid: Warning - EnsureAutoPilotOn failed after starting")
        ; Continue anyway
    } else {
         DebugLog("ActionRaid: EnsureAutoPilotOn completed successfully (check its logs for details).")
    }

    DebugLog("ActionRaid: --- Success! Raid started. Returning 'started'. ---")
    return "started"
}

; --- Add MonitorRaid function ---
MonitorRaidProgress() {
    global Bot
    ; Note: BotMain logs "monitoring Raid"

    ; 1. Check for Completion first (using IsRaidComplete helper)
    isComplete := IsActionComplete()
    DebugLog("MonitorRaid: IsActionComplete returned true")
    if (isComplete) {
        DebugLog("MonitorRaid: Raid Complete detected.")

        ; Check if configured for single raid or multiple
        if (Bot.Raid.Conf.List.MaxIndex() = 1) {
            ; --- SINGLE RAID CONFIG: Attempt Rerun ---
            DebugLog("MonitorRaid: Single raid config - attempting Rerun.")
            if (ClickRerun()) {
                 DebugLog("MonitorRaid: ClickRerun succeeded. Sleeping and checking resources...")
                 Sleep, 2000 ; Wait after clicking rerun
                 outOfRes := CheckOutOfResources() ; Check resources AFTER clicking rerun
                 returnVal := outOfRes ? "outofresource" : "raid_rerun" ; Return "raid_rerun" if resources OK
                 DebugLog("MonitorRaid: Rerun attempt finished. Returning '" . returnVal . "'")
                 return returnVal
            } else {
                 DebugLog("MonitorRaid: ClickRerun failed. Returning 'error'.")
                 return "error" ; Failed to click Rerun
            }

        } else {
            ; --- MULTI RAID CONFIG: Attempt Town/Exit ---
            DebugLog("MonitorRaid: Multi-raid config - attempting ClickTownOnComplete.")
            if (ClickTownOnComplete()) { ; Reuse the generic Town button clicker
                 DebugLog("MonitorRaid: ClickTownOnComplete succeeded.")
                 Sleep, 1000 ; Wait after clicking town
                 ; NOTE: We don't usually need to check resources when just exiting to town.
                 DebugLog("MonitorRaid: Returning 'raid_completed_next'.")
                 return "raid_completed_next" ; Signal BotMain to setup next raid in list
            } else {
                 DebugLog("MonitorRaid: ClickTownOnComplete failed. Looking for Raid Accept button as fallback...")
                 ; Fallback: Maybe an "Accept" button instead of "Town"?
                 acceptClicked := ClickRaidAccept()
                 if (acceptClicked) {
                     DebugLog("MonitorRaid: ClickRaidAccept (fallback) succeeded.")
                     Sleep, 1000
                     DebugLog("MonitorRaid: Returning 'raid_completed_next'.")
                     return "raid_completed_next" ; Signal BotMain to setup next raid
                 } else {
                     DebugLog("MonitorRaid: ERROR - Neither Town nor Accept button found after multi-raid completion.")
                     return "error" ; Stuck on completion screen
                 }
            }
        }
    }

    ; 2. If NOT complete, check for Failure/Interrupt States
    disconnected := IsDisconnected()
    DebugLog("MonitorRaid: IsDisconnected returned: '" . (disconnected ? "True" : "False") . "'")
    if (disconnected) {
        DebugLog("MonitorRaid: Disconnected detected.")
        AttemptReconnect()
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorRaid: State changed to NotLoggedIn. Returning 'disconnected'.")
        return "disconnected"
    }

    playerDead := IsPlayerDead()
    DebugLog("MonitorRaid: IsPlayerDead returned: '" . (playerDead ? "True" : "False") . "'")
    if (playerDead) {
        DebugLog("MonitorRaid: Player Dead detected.")
        Send, {Esc} ; Try to dismiss
        Sleep, 800
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorRaid: State changed to NotLoggedIn. Returning 'player_dead'.")
        return "player_dead"
    }

    ; Removed the CheckOutOfResources from here, as per your request

    ; Check for in-progress dialogue
    dialogueHandled := HandleInProgressDialogue()
    if (dialogueHandled) {
        DebugLog("MonitorRaid: Handled in-progress dialogue during raid.")
        ; Continue monitoring after handling
    }

    ; 3. Still In Progress
    DebugLog("MonitorRaid: No end/fail/dialogue state change detected. Returning 'in_progress'.")
    return "in_progress"
}

ActionTrials()      {
    global Bot
    DebugLog("ActionTrials: --- Entered function ---")
    ; Add logic
    if (CheckOutOfResources()) 
        return "outofresource"
    DebugLog("ActionTrials: --- Success! Returning 'success'. ---")
    return "success"
                    }


ActionExpedition()  {
    global Bot
    DebugLog("ActionExpedition: --- Entered function ---")
    ; Add logic
    if (CheckOutOfResources())
        return "outofresource"
    DebugLog("ActionExpedition: --- Success! Returning 'success'. ---")
    return "success"
                    }


ActionGauntlet()    {
    global Bot
    DebugLog("ActionGauntlet: --- Entered function ---")
    ; Add logic
    if (CheckOutOfResources())
        return "outofresource"
    DebugLog("ActionGauntlet: --- Success! Returning 'success'. ---")
    return "success"
                    }

;———————————————————————————————————————————————————————————————
; === Helper functions (all reference Bot.ocr.* patterns) ===

IsMainScreenAnchor() {
    global Bot
    SoundBeep, 1000, 500
    return FindText(X, Y, 790-150000, 579-150000, 790+150000, 579+150000, 0, 0, Bot.ocr.QuestIcon)
}

AttemptReconnect() {
    global Bot
     ; No entry/exit needed unless problematic. Log IF found.
    DebugLog("AttemptReconnect: Checking for disconnect message...")
    if FindText(X, Y, 696, 470, 2503, 1632, 0, 0, Bot.ocr.Disconnect) {
         DebugLog("AttemptReconnect: Found disconnect message. Clicking OK.")
        FindText().Click(X,Y,"L")
        Sleep, 2000
    } else {
         DebugLog("AttemptReconnect: Disconnect message not found.")
    }
}

CheckOutOfResources() {
    global Bot
    DebugLog("CheckOutOfResources: --- Entered Function ---")
    ; Ensure Bot.ocr.OutOfResources pattern is correct
    result := FindText(X, Y, 1000-150000, 800-150000, 1000+150000, 800+150000, 0, 0, Bot.ocr.OutOfResources)
    found := result ? "True" : "False"
    DebugLog("CheckOutOfResources: FindText result: " . found . " --- Exiting function ---")
    return result ; Return FindText result
}

IsQuestWindowOpen() {
    global Bot
    DebugLog("IsQuestWindowOpen: --- Entered function ---")
    ; Use a reliable element WITHIN the quest window (e.g., the Accept button is good if using wide coords)
    ; Ensure Bot.ocr.Button.Accept pattern is correct
    result := FindText(X, Y, 1045-150000, 642-150000, 1045+150000, 642+150000, 0, 0, Bot.ocr.Button.QuestWindowOpen)
    found := result ? "True" : "False" ; Convert FindText result to True/False string
    DebugLog("IsQuestWindowOpen: FindText for the zone button within quest returned: " . found)
    DebugLog("IsQuestWindowOpen: --- Exiting function ---")
    return result ; Return the original FindText result (evaluates correctly in IFs)
}

ClickQuestIcon() {
    global Bot
    DebugLog("ClickQuestIcon: --- Entered function ---")
    ; Ensure Bot.ocr.QuestIcon pattern is correct
    found := FindText(X, Y, 790-150000, 579-150000, 790+150000, 579+150000, 0, 0, Bot.ocr.QuestIcon)
    if (found) {
        DebugLog("ClickQuestIcon: Found, Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 100 ; Short sleep after click
    } else {
        DebugLog("ClickQuestIcon: Quest Icon NOT found!")
    }
    DebugLog("ClickQuestIcon: --- Exiting function ---")
    ; This function doesn't need to return anything, it just performs an action.
}

GetZoneNameFromPattern(patternToFind) {
    global Bot
    for index, patternInArray in Bot.ocr.Zone
    {
        if (patternInArray = patternToFind)
        {
            return "Zone" . index ; Return "Zone1", "Zone2" etc.
        }
    }
    return "UnknownZone" ; Return this if pattern not found in the array
}

EnsureCorrectZone(targetZonePattern) {
    global Bot
    targetZoneName := GetZoneNameFromPattern(targetZonePattern) ; Get target name for logging
    DebugLog("EnsureCorrectZone: --- Entered Function --- Target Zone: " . targetZoneName)

    attempts := 0
    currentZoneName := DetectCurrentZoneName() ; Get current name
    DebugLog("EnsureCorrectZone: Initial detected zone: '" . currentZoneName . "' (Attempt " . attempts . ")")

    ; Compare NAMES for loop condition
    while (currentZoneName != targetZoneName && attempts < 20) {
        DebugLog("EnsureCorrectZone: Mismatch! Current='" . currentZoneName . "', Target='" . targetZoneName . "'. Attempt " . attempts)

        ; --- Determine Click Direction (Needs Robust Logic) ---
        ; This requires knowing the order of zones. Assuming numerical order for now.
        ; Extract numbers from "ZoneN" strings
        currentZoneNum := SubStr(currentZoneName, 5) ; Get number part
        targetZoneNum := SubStr(targetZoneName, 5)   ; Get number part

        if (currentZoneNum is not number or targetZoneNum is not number) {
            DebugLog("EnsureCorrectZone: ERROR - Could not determine zone numbers for direction ('" . currentZoneName . "', '" . targetZoneName . "'). Clicking Right as default.")
            ClickRightArrow()
        } else if (currentZoneNum < targetZoneNum) {
             DebugLog("EnsureCorrectZone: Clicking Right Arrow.")
             ClickRightArrow()
        } else {
             DebugLog("EnsureCorrectZone: Clicking Left Arrow.")
             ClickLeftArrow()
        }
        ; --- End Direction Logic ---

        Sleep, 600           ; Increased sleep slightly
        currentZoneName := DetectCurrentZoneName() ; Detect NAME again
        attempts++
        DebugLog("EnsureCorrectZone: After arrow click & sleep, detected zone: '" . currentZoneName . "' (Attempt " . attempts . ")")

    } ; End while loop

    if (currentZoneName = targetZoneName) {
        DebugLog("EnsureCorrectZone: --- Success! Target zone '" . targetZoneName . "' reached. ---")
        return true
    } else {
        DebugLog("EnsureCorrectZone: --- Failed! Target zone '" . targetZoneName . "' NOT reached after " . attempts . " attempts. ---")
        return false
    }
}

DetectCurrentZoneName() {
    global Bot
    DebugLog("DetectCurrentZoneName: --- Entered function (searching 400,200 to 800,300) ---")
    for index, pat in Bot.ocr.Zone {
        ; Ensure these coordinates are correct for seeing the Zone Title Text
        if FindText(X, Y, 1191, 537, 1999, 700, 0, 0, pat) {
            zoneName := "Zone" . index
            DebugLog("DetectCurrentZoneName: Found " . zoneName . " --- Exiting function ---")
            return zoneName ; Return the NAME ("Zone1", "Zone2", etc.)
        }
    }
    DebugLog("DetectCurrentZoneName: No known zone pattern found! --- Exiting function ---")
    return "" ; Return empty if no known zone found
}

ClickRightArrow() {
    global Bot
    DebugLog("ClickRightArrow: Searching for right arrow (2128,891 to 2640,1378)...")
    if FindText(X, Y, 2048, 658, 2721, 1691, 0, 0, Bot.ocr.ZoneArrowRight) {
        DebugLog("ClickRightArrow: Found, Clicking.")
        FindText().Click(X,Y,"L")
    } else {
        DebugLog("ClickRightArrow: Arrow NOT found!")
    }
    Sleep, 400
}

ClickLeftArrow() {
    global Bot
     DebugLog("ClickLeftArrow: Searching for left arrow (592,742 to 1005,1383)...")
    if FindText(X, Y, 465, 716, 1021, 1448, 0, 0, Bot.ocr.ZoneArrowLeft) {
         DebugLog("ClickLeftArrow: Found, Clicking.")
        FindText().Click(X,Y,"L")
    } else {
         DebugLog("ClickLeftArrow: Arrow NOT found!")
    }
    Sleep, 400
}

EnsureCorrectDungeon(zoneName, dungeonName) { ; Takes NAMES now
    global Bot ; Still need Bot for patterns
    DebugLog("EnsureCorrectDungeon: --- Entered Function --- Zone Name: " . zoneName . ", Dungeon Name: " . dungeonName)
    foundResult := false ; Default to false

    if (!Bot.ocr.DungeonMapping.HasKey(zoneName)) {
        DebugLog("EnsureCorrectDungeon: ERROR - Zone '" . zoneName . "' not found in DungeonMapping.")
        return false ; Return simple false (0)
    }
    dungeonPatternList := Bot.ocr.DungeonMapping[zoneName]
    dungeonIndex := SubStr(dungeonName, 8)

    if (dungeonIndex is not number or dungeonIndex < 1 || dungeonIndex > dungeonPatternList.MaxIndex()) {
         DebugLog("EnsureCorrectDungeon: ERROR - Invalid dungeon index '" . dungeonIndex . "' extracted from '" . dungeonName . "'.")
         return false ; Return simple false (0)
    }

    targetDungeonPattern := dungeonPatternList[dungeonIndex]
    DebugLog("EnsureCorrectDungeon: Target Dungeon Pattern starts: " . SubStr(targetDungeonPattern, 1, 10) . "...")
    DebugLog("EnsureCorrectDungeon: Searching for pattern in region 660,496 to 2501,1680...")

    ; Perform FindText and store the result OBJECT in foundResult
    ; DO NOT use global X, Y here.
    foundResult := FindText(X, Y, 660, 496, 2501, 1680, 0, 0, targetDungeonPattern)

    if (foundResult) {
        DebugLog("EnsureCorrectDungeon: FindText result: True (Pattern Found) --- Exiting function ---")
    } else {
        DebugLog("EnsureCorrectDungeon: FindText result: False (Pattern Not Found) --- Exiting function ---")
    }
    ; Return the raw FindText result OBJECT (evaluates correctly in IFs)
    return foundResult
}

SelectHeroic() {
    global Bot
    DebugLog("SelectHeroic: --- Entered Function ---")
    ; Ensure Bot.ocr.Button.Heroic pattern is correct
    DebugLog("SelectHeroic: Searching for Heroic button...")
    heroicButton := FindText(X, Y, 2020-150000, 1033-150000, 2020+150000, 1033+150000, 0, 0, Bot.ocr.Button.Heroic)
    if (heroicButton) {
         DebugLog("SelectHeroic: Found Heroic button-Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 950
        DebugLog("SelectHeroic: Returning True. --- Exiting function ---")
        return true
    } else {
        DebugLog("SelectHeroic: Heroic button NOT found. Returning False. --- Exiting function ---")
        return false
    }
}

ClickAcceptQuest() {
    global Bot
    DebugLog("ClickAcceptQuest: --- Entered Function ---")
    acceptButtonFound := false

    ; Now look for the Accept button
     DebugLog("ClickAcceptQuest: Searching for Accept button...")
    ; Ensure Bot.ocr.Button.Accept pattern is correct
    if FindText(X, Y, 1861-150000, 1539-150000, 1861+150000, 1539+150000, 0, 0, Bot.ocr.Button.Accept) {
        acceptButtonFound := true
        DebugLog("ClickAcceptQuest: Found Accept button-Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 900
        ; Check AGAIN for OutOfResources immediately after clicking Accept, as it might pop up then
        if (CheckOutOfResources()) {
             DebugLog("ClickAcceptQuest: Out of resources detected AFTER clicking Accept. Returning 'outofresource'. --- Exiting function ---")
             return "outofresource"
        }
        DebugLog("ClickAcceptQuest: Clicked Accept, no immediate 'Out of Resources'. Returning 'confirmed'. --- Exiting function ---")
        return "confirmed"
    } else {
        DebugLog("ClickAcceptQuest: Accept button NOT found. Returning 'notfound'. --- Exiting function ---")
        return "notfound" ; Return a specific value if not found
    }
}

EnsureAutoPilotOn() {
    global Bot
    DebugLog("EnsureAutoPilotOn: --- Entered function (will try up to 3 times) ---")
    foundRed := false, foundGreen := false, variation := 0.1 ; Keep color variation

    Loop, 3 ; Try up to 3 times
    {
        DebugLog("EnsureAutoPilotOn: Attempt " . A_Index . " of 3.")

        ; 1. Check for RED (Off) button
        DebugLog("EnsureAutoPilotOn: Searching for AutoPilot RED button (Variation: " . variation . ")")
        foundRed := FindText(X, Y, 1186, 384, 3207, 1659, variation, 0, Bot.ocr.AutoPilotRed)

        if (foundRed) {
            DebugLog("EnsureAutoPilotOn: Found RED AutoPilot button. Sending {Space} to toggle ON.")
            Send, {space}
            Sleep, 300 ; Short sleep after sending key
            DebugLog("EnsureAutoPilotOn: --- Exiting function (Action Taken) ---")
            return true ; Success - Exit function immediately
        }

        ; 2. If RED wasn't found, check for GREEN (On) button
        DebugLog("EnsureAutoPilotOn: RED not found. Searching for AutoPilot GREEN button (Variation: " . variation . ")")
        foundGreen := FindText(X, Y, 2480-150000, 1060-150000, 2480+150000, 1060+150000, variation, 0, Bot.ocr.AutoPilotGreen)

        if (foundGreen) {
            DebugLog("EnsureAutoPilotOn: Found GREEN AutoPilot button (already on). --- Exiting function (State Confirmed) ---")
            return true ; Success - Exit function immediately
        }

        ; 3. If neither was found on this attempt
        DebugLog("EnsureAutoPilotOn: Attempt " . A_Index . ": Neither RED nor GREEN button found.")
        if (A_Index < 3) { ; Don't sleep after the last attempt
             DebugLog("EnsureAutoPilotOn: Sleeping 400ms before next attempt.")
             Sleep, 400
        }
    } ; End Loop

    ; If loop finishes without returning true, then it failed all attempts
    DebugLog("EnsureAutoPilotOn: Neither button found after 3 attempts. --- Exiting function (Failed) ---")
    return false
}

IsActionComplete() {
    global Bot
    DebugLog("IsActionComplete: --- Entered Function ---")
    ; Checking for "Town" button using wide coords
    result := FindText(X, Y, 1463-150000, 1563-150000, 1463+150000, 1563+150000, 0, 0, Bot.ocr.Button.Town)
    found := result ? "True" : "False"
    DebugLog("IsActionComplete: FindText for Town button returned: " . found . " --- Exiting function ---")
    return result
}

IsDisconnected() {
    global Bot
    DebugLog("IsDisconnected: --- Entered Function ---")
    ; Checking for disconnect popup in specific region
    result := FindText(X, Y, 696, 470, 2503, 1632, 0, 0, Bot.ocr.Disconnect)
     found := result ? "True" : "False"
    DebugLog("IsDisconnected: FindText for Disconnect pattern returned: " . found . " --- Exiting function ---")
    return result
}

IsPlayerDead() {
    global Bot
    DebugLog("IsPlayerDead: --- Entered Function ---")
    ; Checking for death overlay in specific region
    result := FindText(X, Y, 672, 371, 2508, 944, 0, 0, Bot.ocr.PlayerDead)
    found := result ? "True" : "False"
    DebugLog("IsPlayerDead: FindText for PlayerDead pattern returned: " . found . " --- Exiting function ---")
    return result
}

ClickRerun() {
    global Bot
    DebugLog("ClickRerun: --- Entered Function ---")
    ; Checking for "Rerun" button using wide coords
    if FindText(X, Y, 1463-150000, 1563-150000, 1463+150000, 1563+150000, 0, 0, Bot.ocr.Button.Rerun) {
        DebugLog("ClickRerun: Found Rerun button-Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 500
        return true
    } else {
         DebugLog("ClickRerun: Rerun button NOT found!")
         return false
    }
     DebugLog("This should not be reached")
}

ClickTownOnComplete() {
    global Bot
    DebugLog("ClickTownOnComplete: --- Entered Function ---")
    ; Checking for "Town" button using wide coords
    if FindText(X, Y, 1796-150000, 1532-150000, 1796+150000, 1532+150000, 0, 0, Bot.ocr.Button.Town) {
        DebugLog("ClickTownOnComplete: Found Town button-Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 500
        DebugLog("ClickTownOnComplete: Returning True. --- Exiting function ---")
        return true
    } else {
         DebugLog("ClickTownOnComplete: Town button NOT found! Returning False. --- Exiting function ---")
        return false
    }
}

HandleInProgressDialogue() {
    global Bot
    ; No entry/exit needed unless it becomes problematic. Just log IF found.
    ; Checking for dialogue arrow in specific region
    if FindText(X, Y, 1859, 727, 2495, 1369, 0, 0, Bot.ocr.InProgressDialogue) {
        DebugLog("HandleInProgressDialogue: Found dialogue arrow. Sending {Esc}.")
        Send, {Esc}
        Sleep, 200
        return true ; Indicate dialogue was handled
    }
    return false ; Indicate no dialogue found/handled
}

;── PVP helpers ─────────────────────────

IsPvpWindowOpen() {
    global Bot
    return FindText(X, Y, 679, 453, 2504, 1632, 0, 0, Bot.ocr.Pvp.Window)
}

ClickPVPButton() {
    global Bot
    if FindText(X, Y, 612, 466, 2495, 1646, 0, 0, Bot.ocr.Pvp.Button) {
        FindText().Click(X, Y, "L")
        Sleep, 800
        return true
    }
    return false
}

EnsureCorrectTickets(choice) { ; 'choice' is the desired number (1-5)
    global Bot, X, Y ; Need X, Y for FindText output vars
    DebugLog("EnsureCorrectTickets: --- Entered function (Desired Choice: " . choice . ") ---")

    DebugLog("EnsureCorrectTickets: PART 1 - Checking current ticket selection...")
    current := "" ; Variable to store the currently selected ticket number (1-5)
    for i, pat in Bot.ocr.Pvp.TicketSelection {
        ; Region where ticket selection text is displayed: 675, 470, 2496, 1641
        if FindText(X, Y, 581, 426, 2497, 1721, 0, 0, pat) {
            current := i ; Store the index of the pattern found
            DebugLog("EnsureCorrectTickets: Found displayed ticket pattern index " . i)
            break ; Exit loop once found
        }
    }

    if (current = choice) {
        DebugLog("EnsureCorrectTickets: Tickets already set to " . choice . ". Returning True. --- Exiting function ---")
        return true ; Already correct, EXIT HERE
    }

    if (current != "") {
        DebugLog("EnsureCorrectTickets: PART 2 - Mismatch. Current is " . current . ", desired is " . choice . ". Clicking dropdown trigger.")
    } else {
        DebugLog("EnsureCorrectTickets: PART 2 - Could not determine current selection. Attempting to click dropdown trigger anyway.")
    }
    DebugLog("EnsureCorrectTickets: Searching for dropdown trigger button...")
    ; Wide coordinates based on legacy code anchor 2030, 920 - VERIFY THIS PATTERN AND COORDS
    dropdownTriggerPattern := Bot.ocr.Pvp.TicketDropdownTrigger ; Make sure this pattern is defined in Patterns.ahk
    if (FindText(X, Y, 2030-150000, 920-150000, 2030+150000, 920+150000, 0, 0, dropdownTriggerPattern)) {
        DebugLog("EnsureCorrectTickets: Found dropdown trigger at X=" . X . " Y=" . Y . ". Clicking.")
        FindText().Click(X, Y, "L") ; Click the trigger
        Sleep, 990 ; Wait for menu to open (from legacy code)
    } else {
        DebugLog("EnsureCorrectTickets: Dropdown trigger button NOT found! Returning False. --- Exiting function ---")
        return false ; Cannot proceed if trigger isn't found
    }

    entryPattern := Bot.ocr.Pvp.TicketMenu[choice] ; Get pattern for the desired choice number from Patterns.ahk
    if (entryPattern = "") {
         DebugLog("EnsureCorrectTickets: ERROR - No pattern defined for TicketMenu choice " . choice . ". Returning False.")
         return false
    }
    DebugLog("EnsureCorrectTickets: PART 3 - Searching for menu item pattern for choice " . choice . "...")
    ; Region where dropdown menu appears (from legacy code): 905, 470, 2196, 1669 - VERIFY THIS REGION
    if (FindText(X, Y, 905, 470, 2196, 1669, 0, 0, entryPattern)) {
        DebugLog("EnsureCorrectTickets: Found menu item " . choice . " at X=" . X . " Y=" . Y . ". Clicking.")
        FindText().Click(X, Y, "L") ; Click the menu item
        Sleep, 990 ; Wait after click (from legacy code)

        ; Optional Verification Step (Recommended)
        expectedDisplayPattern := Bot.ocr.Pvp.TicketSelection[choice]
        Sleep, 300 ; Short extra sleep for UI update
        if (FindText(0, 0, 675, 470, 2496, 1641, 0, 0, expectedDisplayPattern)) {
             DebugLog("EnsureCorrectTickets: Tickets successfully changed to " . choice . " (verified). Returning True. --- Exiting function ---")
             return true
        } else {
             DebugLog("EnsureCorrectTickets: Clicked menu item " . choice . ", but verification failed! Returning False. --- Exiting function ---")
             return false
        }
    } else {
        DebugLog("EnsureCorrectTickets: FAILED to find menu item pattern for choice " . choice . ". Returning False. --- Exiting function ---")
        Send, {Esc} ; Try to close dropdown if click failed
        return false
    }
}

ClickPvpPlay() {
    global Bot
    if FindText(X, Y, 659, 464, 2503, 1629, 0, 0, Bot.ocr.Pvp.PlayButton) {
        FindText().Click(X, Y, "L")
        Sleep, 10
        Mousemove 300, 300
        Sleep, 800
        return true
    }
    return false
}

OpponentsVisible() {
    global Bot
    return FindText(X, Y, 451, 420, 2520, 1735, 0.09, 0.09, Bot.ocr.Pvp.OpponentList)
}

SelectPvpOpponent(choice) {
    global Bot
    DebugLog("SelectPvpOpponent: --- Entered function (User Choice: " . choice . ") ---")

    DebugLog("SelectPvpOpponent: Searching for opponent entries...")
    hits := FindText(0, 0, 451, 420, 2520, 1735, 0.09, 0.09, Bot.ocr.Pvp.OpponentList)

    if !(hits) {
        DebugLog("SelectPvpOpponent: No opponents found! Returning False. --- Exiting function ---")
        return false
    }
    DebugLog("SelectPvpOpponent: Found " . hits.MaxIndex() . " opponent button(s).")

    map := [3, 1, 4, 2] ; Adjust map if needed!

    if (choice < 1 || choice > map.MaxIndex()) {
         DebugLog("SelectPvpOpponent: ERROR - Invalid PvpOpponentChoice (" . choice . ") configured. Must be between 1 and " . map.MaxIndex() . ". Returning False.")
         return false
    }

    realIdx := map[choice]
    DebugLog("SelectPvpOpponent: User choice " . choice . " maps to hits index " . realIdx)

    if (!hits[realIdx]) {
         DebugLog("SelectPvpOpponent: ERROR - Mapped index " . realIdx . " does not exist in the found 'hits' array (only found " . hits.MaxIndex() . " hits). Maybe FindText failed? Returning False.")
         return false
    }

    ; Get the specific hit object to click based on the mapped index
    hitToClick := hits[realIdx]
    clickX := hitToClick.x ; Get coordinates explicitly
    clickY := hitToClick.y

    DebugLog("SelectPvpOpponent: Clicking opponent at mapped index " . realIdx . " using coordinates (X=" . clickX . " Y=" . clickY . ")")


    FindText().Click(clickX, clickY, "L")


    Sleep, 300

    DebugLog("SelectPvpOpponent: Returning True. --- Exiting function ---")
    return true
}

ClickPvpAccept() {
    global Bot
    if FindText(X, Y, 1862-150000, 1541-150000, 1862+150000, 1541+150000, 0, 0, Bot.ocr.Pvp.AcceptButton) {
        FindText().Click(X, Y, "L")
        Sleep, 800
        return true
    }
    DebugLog("ClickPvpAccept: Accept button not found.")
    return false
}

;── Raid helpers ─────────────────────────
IsRaidWindowOpen() {
    global Bot
    DebugLog("IsRaidWindowOpen: Checking for Raid window pattern...")
    result := FindText(X, Y, 376, 409, 2761, 1746, 0, 0, Bot.ocr.RaidWindow) 
    found := result ? "True" : "False"
    DebugLog("IsRaidWindowOpen: FindText result: " . found)
    return result
}

ClickRaidIcon() {
    global Bot
    DebugLog("ClickRaidIcon: Searching for Raid icon on main screen...")
    if FindText(X, Y, 710, 1014, 858, 1158, 0, 0, Bot.ocr.RaidIcon) {
        DebugLog("ClickRaidIcon: Found. Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 900 ; Short sleep after click
        return true
    } else {
        DebugLog("ClickRaidIcon: Raid icon NOT found!")
        return false
    }
}

EnsureCorrectRaidSelected(targetRaidIndex) {
    global Bot
    DebugLog("EnsureCorrectRaidSelected: --- OPTIMIZED Entered Function --- Target Index: " . targetRaidIndex)

    ; --- Step 1: Detect Current Raid Index (with retry) ---
    currentIndex := 0 ; Initialize to 0 (failure state)
    Loop, 2 ; Try up to 2 times to detect the current raid
    {
        DebugLog("EnsureCorrectRaidSelected: Detecting current raid index (Attempt " . A_Index . " of 2)...")
        currentIndex := DetectCurrentlyDisplayedRaidIndex()
        if (currentIndex != 0) { ; If detection succeeded
            DebugLog("EnsureCorrectRaidSelected: Detected index '" . currentIndex . "' on attempt " . A_Index . ".")
            break ; Exit the detection loop
        }
        if (A_Index = 1) { ; If first attempt failed, wait before retrying
            DebugLog("EnsureCorrectRaidSelected: Attempt 1 failed. Sleeping 500ms before retry.")
            Sleep, 500
        }
    }

    ; Check if detection failed after all attempts
    if (currentIndex = 0) {
        DebugLog("EnsureCorrectRaidSelected: Failed to detect initial raid index after 2 attempts. Returning False.")
        return false
    }

    ; --- Proceed only if detection was successful ---
    DebugLog("EnsureCorrectRaidSelected: Initial detected index: '" . currentIndex . "'")

    if (currentIndex = targetRaidIndex) { ; Already on the correct raid
        DebugLog("EnsureCorrectRaidSelected: Already on target raid index " . targetRaidIndex . ". Returning True.")
        return true
    }

    ; --- Step 2: Calculate Clicks Needed ---
    totalRaids := Bot.ocr.RaidMapping.MaxIndex() ; Get total number of raids defined
    if (totalRaids <= 1) { ; Should not happen if check passed in ActionRaid, but safety check
         DebugLog("EnsureCorrectRaidSelected: Only 1 or fewer raids defined in mapping. Cannot navigate.")
         return (currentIndex = targetRaidIndex) ; Return true only if already correct
    }

    ; Calculate distance in both directions (handling wrap-around)
    diffRight := targetRaidIndex - currentIndex
    if (diffRight < 0) { ; Wrap around going right (e.g., from 10 to 2)
        diffRight += totalRaids
    }

    diffLeft := currentIndex - targetRaidIndex
    if (diffLeft < 0) { ; Wrap around going left (e.g., from 2 to 10)
         diffLeft += totalRaids
    }

    ; Determine direction and number of clicks
    numClicks := 0
    clickDirection := ""
    if (diffLeft < diffRight) {
        numClicks := diffLeft
        clickDirection := "Left"
    } else { ; Includes diffLeft = diffRight case, prefer right? Or choose based on shortest path? Let's prefer right if equal.
        numClicks := diffRight
        clickDirection := "Right"
    }

    if (numClicks = 0) { ; Should only happen if current = target, already handled
        DebugLog("EnsureCorrectRaidSelected: Calculated 0 clicks needed? Returning True (already correct).")
        return true
    }

    DebugLog("EnsureCorrectRaidSelected: Need to click " . clickDirection . " " . numClicks . " time(s).")

    ; --- Step 3: Perform Arrow Clicks ---
    Loop, %numClicks%
    {
        DebugLog("EnsureCorrectRaidSelected: Clicking " . clickDirection . " Arrow (Click " . A_Index . " of " . numClicks . ")")
        if (clickDirection = "Left") {
            if (!ClickRaidLeftArrow()) { ; Check if click function indicated failure
                 DebugLog("EnsureCorrectRaidSelected: ClickRaidLeftArrow failed during loop. Aborting.")
                 return false ; Abort if arrow not found
            }
        } else { ; Must be Right
            if (!ClickRaidRightArrow()) {
                 DebugLog("EnsureCorrectRaidSelected: ClickRaidRightArrow failed during loop. Aborting.")
                 return false ; Abort if arrow not found
            }
        }
        Sleep, 150 ; Smaller sleep between clicks - adjust if needed
    }

    ; --- Step 4: Final Verification ---
    DebugLog("EnsureCorrectRaidSelected: Finished clicking arrows. Verifying final position...")
    Sleep, 600 ; Wait a bit longer for screen to settle after last click

    finalIndex := DetectCurrentlyDisplayedRaidIndex()
    DebugLog("EnsureCorrectRaidSelected: Final detected index: '" . finalIndex . "'")

    if (finalIndex = targetRaidIndex) {
        DebugLog("EnsureCorrectRaidSelected: --- Success! Target raid index '" . targetRaidIndex . "' is displayed. ---")
        return true
    } else {
        DebugLog("EnsureCorrectRaidSelected: --- Failed! Target raid index '" . targetRaidIndex . "' NOT displayed after clicking. Detected '" . finalIndex . "' instead. ---")
        return false
    }
}

DetectCurrentlyDisplayedRaidIndex() {
    global Bot
    DebugLog("DetectCurrentlyDisplayedRaidIndex: --- Entered function ---")

    for index, pattern in Bot.ocr.RaidMapping {
        if (pattern = "") ; Skip empty patterns if any
            continue
        if FindText(X, Y, 603, 462, 2539, 1728, 0, 0, pattern) {
            DebugLog("DetectCurrentlyDisplayedRaidIndex: Found pattern for index " . index . ". --- Exiting function ---")
            return index ; Return the INDEX (1, 2, 3...)
        }
    }
    DebugLog("DetectCurrentlyDisplayedRaidIndex: No known raid pattern found! --- Exiting function ---")
    return 0 ; Return 0 if no known raid found
}

ClickRaidLeftArrow() {
    global Bot
    DebugLog("ClickRaidLeftArrow: Searching for Raid Left Arrow...")

    if FindText(X, Y, 629, 492, 1603, 1678, 0, 0, Bot.ocr.RaidLeftArrow) {
        DebugLog("ClickRaidLeftArrow: Found. Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 400 ; Short sleep after click
        return true
    } else {
        DebugLog("ClickRaidLeftArrow: Arrow NOT found!")
        return false
    }
}

ClickRaidRightArrow() {
    global Bot
    DebugLog("ClickRaidRightArrow: Searching for Raid Right Arrow...")

    if FindText(X, Y, 1587, 480, 2571, 1662, 0, 0, Bot.ocr.RaidRightArrow) {
        DebugLog("ClickRaidRightArrow: Found. Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 400 ; Short sleep after click
        return true
    } else {
        DebugLog("ClickRaidRightArrow: Arrow NOT found!")
        return false
    }
}

ClickRaidSummonButton() {
    global Bot
    DebugLog("ClickRaidSummonButton: Searching for Raid Summon button...")
    if FindText(X, Y, 659, 482, 2521, 1642, 0, 0, Bot.ocr.Button.RaidSummon) {
        DebugLog("ClickRaidSummonButton: Found. Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 900 ; Short sleep after click
        return true
    } else {
        DebugLog("ClickRaidSummonButton: Raid Summon button NOT found!")
        return false
    }
}

ClickPreRaidDialogue() {
    global Bot
    DebugLog("ClickPreRaidDialogue: Searching for Pre-Raid dialogue...")
    if FindText(X, Y, 1868, 617, 2804, 1745, 0, 0, Bot.ocr.PreRaidDialogue) {
        DebugLog("ClickPreRaidDialogue: Found. Sending {Esc}.")
        Send, {Esc}
        Sleep, 200 ; Short sleep after sending key
        return true
    }
    return false
}

SelectRaidDifficulty(difficultyName) {
    global Bot
    DebugLog("SelectRaidDifficulty: Attempting to select difficulty '" . difficultyName . "'...")
    if (!Bot.ocr.RaidDifficulty.HasKey(difficultyName)) {
        DebugLog("SelectRaidDifficulty: ERROR - Pattern for difficulty '" . difficultyName . "' not defined.")
        return false
    }
    diffPattern := Bot.ocr.RaidDifficulty[difficultyName]
    ; Adjust search region for difficulty buttons
    if (FindText(X, Y, 697, 496, 2495, 1651, 0, 0, diffPattern)) {
        DebugLog("SelectRaidDifficulty: Found pattern for '" . difficultyName . "'. Clicking.")
        FindText().Click(X, Y, "L")
        ; Optional: Add verification step if needed
        return true
    } else {
        DebugLog("SelectRaidDifficulty: Pattern for '" . difficultyName . "' not found.")
        return false
    }
}

ClickRaidPlayButton() {
    global Bot
    DebugLog("ClickRaidPlayButton: Searching for Play button...")
    ; Adjust search region for the play button
    if (FindText(X, Y, 1861-150000, 1539-150000, 1861+150000, 1539+150000, 0, 0, Bot.ocr.Button.Accept)) {
        DebugLog("ClickRaidPlayButton: Found. Clicking.")
        FindText().Click(X, Y, "L")
        return true
    } else {
        DebugLog("ClickRaidPlayButton: Play button not found.")
        return false
    }
}

IsRaidComplete() {
    global Bot
    DebugLog("IsRaidComplete: Checking for Raid completion screen...")
    ; Adjust search region for completion indicators
    result := FindText(X, Y, 800, 300, 2400, 1000, 0, 0, Bot.ocr.Raid.CompletionScreen)
    found := result ? "True" : "False"
    DebugLog("IsRaidComplete: FindText result: " . found)
    return result
}


ClickRaidAccept() {
    global Bot
    DebugLog("ClickRaidAccept: Searching for Accept button on completion screen...")
    ; Adjust search region for the accept button after a raid
    if (FindText(X, Y, 1500, 1400, 2200, 1700, 0, 0, Bot.ocr.Button.Rerun)) { ; Might be same pattern as Bot.ocr.Button.Accept
        DebugLog("ClickRaidAccept: Found. Clicking.")
        FindText().Click(X, Y, "L")
        return true
    } else {
        DebugLog("ClickRaidAccept: Accept button not found.")
        return false
    }
}

;── Hotkey ───────────────────────────────
F12::
{
    global Bot

    if (A_IsPaused) {
        ; --- RESUME ---
        Pause, Off, 1
        
        if (Bot.previousState != "") {
            Bot.gameState := Bot.previousState
            DebugLog("Resumed via hotkey. Restoring previous state: " . Bot.gameState)
            Bot.previousState := ""
        } else {
            Bot.gameState := "NotLoggedIn"
            DebugLog("Resumed via hotkey. No previous state; resetting to NotLoggedIn.")
        }
    }
    else {
        ; --- PAUSE ---
        Bot.previousState := Bot.gameState
        Bot.gameState := "Paused"
        DebugLog("Paused via hotkey. Previous state: " . Bot.previousState)

        Pause, On, 1
    }
    return
}
