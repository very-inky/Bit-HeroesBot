SetBatchLines, -1
#SingleInstance, Force
#Persistent
#Include Debug.ahk
#Include FindText.ahk
#Include Patterns.ahk
Soundbeep, 500, 600
;──────────────────────────────────────────────────────────────
; All OCR patterns come from PatternBot.ahk via the global `Patterns` object.
;──────────────────────────────────────────────────────────────

;——— Build the Bot “context” object —————————————————————————————
global Bot := {}

; 1) Action configurations & rotation
Bot.actionConfig := { Quest: true, PVP: true, WorldBoss: true
                  , Raid: true, Trials: true, Expedition: true, Gauntlet: true }
Bot.actionOrder := ["Quest","PVP","WorldBoss","Raid","Trials","Expedition","Gauntlet"]
Bot.currentActionIndex := 2

; 2) Questing configs
; --- Define the specific Zone PATTERNS and Dungeon NAMES you want to run ---
Bot.desiredZones       := [ Patterns.Zone[3], Patterns.Zone[2] ] ; Use the PATTERN for Zone 3 from Patterns.ahk
Bot.desiredDungeons    := [ "Dungeon2", "Dungeon1" ]       ;  Not all zones have 3 dungeons!
; --- If running multiple configurations, add more pairs!

Bot.currentSelectionIndex := 1

; 3) PVP configs
Bot.PvpTicketChoice   := 4    ; 1–5
Bot.PvpOpponentChoice := 3    ; 1–4

; 4) OCR patterns
Bot.ocr := Patterns       ; so we can do e.g. Bot.ocr.QuestIcon, Bot.ocr.Zone[1], etc.

; 5) State & cooldown tracking
Bot.gameState     := "NotLoggedIn"
Bot.actionCooldown := 1200000  ; 20 min in ms
DebugLog("=== BOT LOADED; initial gameState=" Bot.gameState)
Bot.lastActionTime := {}
for idx, act in Bot.actionOrder
    Bot.lastActionTime[act] := 0

;———————————————————————————————————————————————————————————————
; Kick off the main loop
SetTimer, BotMain, 1000
return

;———————————————————————————————————————————————————————————————
BotMain:
    global Bot

    if (Bot.gameState = "Paused")
        return

    ; === NotLoggedIn ===
    if (Bot.gameState = "NotLoggedIn") {
        DebugLog("NotLoggedIn: looking for quest icon")
        if (IsMainScreenAnchor()) {
            Bot.gameState := "NormalOperation"
            DebugLog("→ NormalOperation")
        } else {
            AttemptReconnect()
            Bot.gameState := "HandlingPopups"
            ; No need to DebugLog state change here, HandlingPopups will log entry
        }
        return
    }

    ; === HandlingPopups ===
    if (Bot.gameState = "HandlingPopups") {
        DebugLog("HandlingPopups: clearing pop‑ups")
        popupAttempts := 0
        ; Loop until main screen anchor is found OR attempts run out
        while (!IsMainScreenAnchor() and popupAttempts < 7) {
            Send, {Esc}
            Sleep, 500
            popupAttempts++
            if (IsDisconnected()) {
                AttemptReconnect() ; This function should have its own logs
                Sleep, 2000
            }
            ; Check anchor again inside loop for faster exit if Esc worked quickly
            if (IsMainScreenAnchor()) {
                DebugLog("HandlingPopups: Main screen anchor found during popup clearing.")
                break ; Exit the while loop early
            }
        }
        ; After loop, determine next state based on whether anchor was found
        finalAnchorCheck := IsMainScreenAnchor()
        nextState := finalAnchorCheck ? "NormalOperation" : "NotLoggedIn"
        DebugLog("HandlingPopups: Finished attempts. Anchor found: " . (finalAnchorCheck ? "Yes" : "No") . ". → " . nextState)
        Bot.gameState := nextState
        return
    }

    ; === NormalOperation ===
    if (Bot.gameState = "NormalOperation") {
        current := Bot.actionOrder[Bot.currentActionIndex]
        now := A_TickCount

        ; skip if disabled in config
        if (! Bot.actionConfig[current]) {
            DebugLog("NormalOperation: Skipping " . current . " (disabled in config)")
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
            return
        }

        ; cooldown check
        if ((now - Bot.lastActionTime[current]) >= Bot.actionCooldown) {
            DebugLog("NormalOperation: Running " . current . " (cooldown ready)")
            result := ""
            Switch current
            {
                Case "Quest":      result := ActionQuest()
                Case "PVP":        result := ActionPVP()
                Case "WorldBoss":  result := ActionWorldBoss()
                Case "Raid":       result := ActionRaid()
                Case "Trials":     result := ActionTrials()
                Case "Expedition": result := ActionExpedition()
                Case "Gauntlet":   result := ActionGauntlet()
                Default:
                    DebugLog("NormalOperation: ERROR - Unknown action '" . current . "'")
                    result := "error_unknown_action"
            }

            ; --- Process action result ---
            DebugLog("BotMain: Action '" . current . "' returned: '" . result . "'") ; Log result

            if (result = "started") {
                Bot.gameState := "ActionRunning"
                DebugLog("BotMain: " . current . " → ActionRunning")
            }
            else if (result = "outofresource") {
                DebugLog("BotMain: '" . current . "' reported 'outofresource'. Setting cooldown and returning to HandlingPopups state.")
                ; No need to call ClosePopup() here - HandlingPopups state will send Esc.

                ; Set the cooldown for the action that failed
                Bot.lastActionTime[current] := now
                DebugLog("BotMain: Cooldown set for " . current)
                Loop, 4
                {
                    Send, {esc}
                    Sleep 600
                }
                ; --- Change state to force UI reset via HandlingPopups logic ---
                Bot.gameState := "HandlingPopups"
                DebugLog("BotMain: State changed to HandlingPopups to ensure return to main screen.")

                ; DO NOT advance Bot.currentActionIndex here.
            }
            else if (result = "disconnected") {
                Bot.gameState := "NotLoggedIn"
                ; No DebugLog needed here, NotLoggedIn state handles its entry log
            }
            else if (current = "PVP" and result = "success") {
                ; loop PVP immediately - do nothing here, next loop iteration will handle it
                 DebugLog("BotMain: PVP returned success, looping PVP immediately.")
            }
            else {
                ; Default case for other results ("retry", "success" for non-PVP, "error", etc.)
                ; Start cooldown & advance to next action
                 DebugLog("BotMain: Action '" . current . "' finished with result '" . result . "'. Starting cooldown and advancing.")
                Bot.lastActionTime[current] := now
                Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
            }
        } else {
            ; skip due to cooldown
            DebugLog("NormalOperation: Skipping " . current . " (on cooldown)")
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1
        }
        return
    }

    ; === ActionRunning ===
    if (Bot.gameState = "ActionRunning") {
        current := Bot.actionOrder[Bot.currentActionIndex]
        DebugLog("ActionRunning: monitoring " . current)
        monitorResult := ""

        ; Call the appropriate monitoring function based on the current action
        if (current = "Quest")
            monitorResult := MonitorQuestProgress()
        else if (current = "PVP")
            monitorResult := MonitorPVPProgress()
        else {
            ; No monitor needed for simple actions (WorldBoss, Raid, etc.)
            DebugLog("ActionRunning: No monitor function for '" . current . "'. Returning to NormalOperation.")
            Bot.gameState := "NormalOperation"
            return
        }

        DebugLog("ActionRunning: Monitor function for '" . current . "' returned: '" . monitorResult . "'")

        ; Process monitor result (example for PVP, adapt as needed for Quest if MonitorQuestProgress returns specific values)
        if (monitorResult = "pvp_completed_continue") {
            DebugLog("ActionRunning: PVP monitor reported completion. Returning to NormalOperation.")
            Bot.gameState := "NormalOperation"
            ; Index is NOT advanced here, allowing PVP to loop if desired by main logic
            return
        }
        else if (monitorResult = "outofresource") { ; This might be specific to PVP monitor? Adapt if needed.
            DebugLog("ActionRunning: Monitor reported 'outofresource' for PVP.")
            Bot.lastActionTime["PVP"] := A_TickCount ; Set cooldown specifically for PVP
            Bot.currentActionIndex := Mod(Bot.currentActionIndex, Bot.actionOrder.Length()) + 1 ; Advance past PVP
            Bot.gameState := "NormalOperation"
            DebugLog("ActionRunning: Cooldown set for PVP, index advanced. Returning to NormalOperation.")
            return
        }
        else if (monitorResult = "disconnected" or monitorResult = "player_dead") {
             DebugLog("ActionRunning: Monitor reported '" . monitorResult . "'. State already changed by monitor function.")
             ; Monitor function should have already changed Bot.gameState to NotLoggedIn
             return
        }
        else if (monitorResult = "start_next_config") {
                 DebugLog("ActionRunning: Monitor reported quest config complete. Advancing config index.")
                 Bot.currentSelectionIndex += 1

                 ; Check if we've run out of configs
                 if (Bot.currentSelectionIndex > Bot.desiredZones.MaxIndex()) {
                    DebugLog("ActionRunning: All quest configs completed. Resetting config index and returning to NormalOperation.")
                    Bot.currentSelectionIndex := 1 ; Reset config index for the next time Quest runs

                    ; --- REMOVED Cooldown set and Action Index advance ---

                    Bot.gameState := "NormalOperation" ; Go back to NormalOperation to evaluate next main action
                 } else {
                    ; Still more configs left, go start the next one
                    DebugLog("ActionRunning: Moving to next quest config (Index: " . Bot.currentSelectionIndex . "). Returning to NormalOperation to start it.")
                    Bot.gameState := "NormalOperation"
                 }
                 return
             }
         else if (monitorResult = "rerun") { ; Specific to single-config Quest monitor
              DebugLog("ActionRunning: Monitor reported 'rerun'. Quest is restarting. Remaining in ActionRunning.")
              ; Do nothing, stay in ActionRunning state
              return
         }
        ; Default: "in_progress" or other non-state-changing results from Monitor
        ; Stay in ActionRunning state and wait for next timer tick
        return
    }
return

;———————————————————————————————————————————————————————————————
; === Quest Flow ===
ActionQuest() {
    global Bot
    DebugLog("ActionQuest: --- Entered function ---")

    ; Check if Quest window is open
    questWinOpen := IsQuestWindowOpen()
    DebugLog("ActionQuest: IsQuestWindowOpen returned: '" . (questWinOpen ? "True" : "False") . "'")

    if (!questWinOpen) {
        DebugLog("ActionQuest: Quest window NOT open, attempting ClickQuestIcon()")
        ClickQuestIcon() ; Assumes this function has its own logs
        Sleep, 600 ; Wait for window to potentially open
        questWinOpen := IsQuestWindowOpen() ; Check again
        DebugLog("ActionQuest: IsQuestWindowOpen (after click) returned: '" . (questWinOpen ? "True" : "False") . "'")
        if (!questWinOpen) {
            DebugLog("ActionQuest: Failed to open quest window after click. Returning 'retry'.")
            return "retry"
        }
    } else {
         DebugLog("ActionQuest: Quest window was already open.")
    }

    ; Get desired targets for this run
    targetZonePattern := Bot.desiredZones[Bot.currentSelectionIndex]
    targetDungeonName := Bot.desiredDungeons[Bot.currentSelectionIndex]
    DebugLog("ActionQuest: Target Zone Pattern starts: " . SubStr(targetZonePattern, 1, 10) . "..., Target Dungeon Name: " . targetDungeonName)

    ; Ensure the correct zone is displayed
    DebugLog("ActionQuest: Calling EnsureCorrectZone(...)")
    zoneCorrect := EnsureCorrectZone(targetZonePattern) ; Pass the PATTERN
    DebugLog("ActionQuest: EnsureCorrectZone returned: '" . zoneCorrect . "'")
    if (!zoneCorrect) {
        DebugLog("ActionQuest: EnsureCorrectZone failed. Returning 'retry'.")
        return "retry"
    }

    ; Get the name of the currently displayed zone (should match target now)
    currentZoneName := DetectCurrentZoneName()
    DebugLog("ActionQuest: Current confirmed zone name for dungeon check: " . currentZoneName)

    ; Check if the desired dungeon pattern is visible
    DebugLog("ActionQuest: Calling EnsureCorrectDungeon(" . currentZoneName . ", " . targetDungeonName . ") to check presence.")
    dungeonPresent := EnsureCorrectDungeon(currentZoneName, targetDungeonName) ; Gets result OBJECT (evaluates true/false)
    DebugLog("ActionQuest: EnsureCorrectDungeon (presence check) returned: '" . (dungeonPresent ? "Object (True)" : "0 (False)") . "'")

    if (!dungeonPresent) { ; Check if the dungeon pattern was found
        DebugLog("ActionQuest: EnsureCorrectDungeon failed (pattern not found). Returning 'retry'.")
        return "retry"
    } else {
        ; Dungeon pattern IS present. Now FIND IT AGAIN to update Global X/Y and CLICK.
        DebugLog("ActionQuest: Dungeon pattern found by check. Finding again to click...")

        ; Retrieve the pattern string again (needed for the local FindText call)
        ; Error handling for invalid zone/dungeon index happens within this block now
        if (!Bot.ocr.DungeonMapping.HasKey(currentZoneName)) {
             DebugLog("ActionQuest: ERROR - Zone '" . currentZoneName . "' not found in DungeonMapping for find-and-click.")
             return "retry"
        }
        dungeonPatternList := Bot.ocr.DungeonMapping[currentZoneName]
        dungeonIndex := SubStr(targetDungeonName, 8)
        if (dungeonIndex is not number or dungeonIndex < 1 || dungeonIndex > dungeonPatternList.MaxIndex()) {
            DebugLog("ActionQuest: ERROR - Invalid dungeon index '" . dungeonIndex . "' for find-and-click.")
            return "retry"
        }
        targetDungeonPattern := dungeonPatternList[dungeonIndex]

        ; Perform FindText AGAIN, this time using X, Y output vars to update globals
        if (FindText(X, Y, 660, 496, 2501, 1680, 0, 0, targetDungeonPattern)) {
             DebugLog("ActionQuest: Found dungeon again- Clicking")
             ; Use the standard click method which relies on the X,Y updated above
             FindText().Click(X, Y, "L")
             Sleep, 900 ; Increased delay after clicking dungeon
        } else {
             DebugLog("ActionQuest: ERROR - Failed to find dungeon pattern for click immediately after check found it!? Returning 'retry'.")
             return "retry" ; Should not happen if EnsureCorrectDungeon just worked, but safety check.
        }
    }

    ; Select Heroic Difficulty
    DebugLog("ActionQuest: Calling SelectHeroic()")
    heroicSelected := SelectHeroic() ; Assumes this function has own logs
    DebugLog("ActionQuest: SelectHeroic returned: '" . heroicSelected . "'")
    if (!heroicSelected) {
         DebugLog("ActionQuest: SelectHeroic failed. Returning 'retry'.")
        return "retry"
    }

    ; Click the final Accept button (which checks for resources)
    DebugLog("ActionQuest: Calling ClickAcceptQuest()")
    acceptResult := ClickAcceptQuest() ; Assumes this function has own logs
    DebugLog("ActionQuest: ClickAcceptQuest returned: '" . acceptResult . "'")

    if (acceptResult = "outofresource") {
         DebugLog("ActionQuest: Detected out of resources. Returning 'outofresource'.")
        return "outofresource"
    }
    if (acceptResult != "confirmed") {
        DebugLog("ActionQuest: ClickAcceptQuest returned unexpected value '" . acceptResult . "'. Returning 'retry'.")
        return "retry"
    }

    ; --- Quest Start Confirmed - Perform one-time AutoPilot check ---
    DebugLog("ActionQuest: Quest accepted. Waiting for quest screen to load before AutoPilot check...")
    Sleep, 1500 ; Wait 1.5 seconds (Adjust as needed)

    DebugLog("ActionQuest: Performing one-time AutoPilot check.")
    autoPilotOk := EnsureAutoPilotOn() ; Assumes this function has own logs
    if (!autoPilotOk) {
        DebugLog("ActionQuest: Warning - EnsureAutoPilotOn failed after starting quest.")
        ; Continue anyway, AutoPilot isn't critical for starting
    } else {
         DebugLog("ActionQuest: EnsureAutoPilotOn completed successfully (check its logs for details).")
    }
    ; --- End AutoPilot Check ---

    DebugLog("ActionQuest: --- Success! All steps completed. Returning 'started'. ---")
    return "started"
}
MonitorQuestProgress() {
    global Bot
    ; Note: No AutoPilot check here anymore.

    if (IsActionComplete()) {
        DebugLog("MonitorQuestProgress: IsActionComplete returned True.")
        if (Bot.desiredZones.Length() = 1) {
            DebugLog("MonitorQuestProgress: Single config - attempting Rerun.")
            ClickRerun()
            Sleep, 1200
            outOfRes := CheckOutOfResources()
            returnVal := outOfRes ? "outofresource" : "rerun"
            DebugLog("MonitorQuestProgress: Rerun attempt finished. Returning '" . returnVal . "'")
            return returnVal
        } else {
            DebugLog("MonitorQuestProgress: Multi-config - attempting ClickTownOnComplete.")
            if (ClickTownOnComplete()) {
                Sleep, 1000
                DebugLog("MonitorQuestProgress: ClickTownOnComplete succeeded. Returning 'start_next_config'")
                return "start_next_config"
            }
            DebugLog("MonitorQuestProgress: ClickTownOnComplete failed. Returning 'error'")
            return "error"
        }
    }
    ; If action is not complete, check for other states:
    if (IsDisconnected()) {
        DebugLog("MonitorQuestProgress: IsDisconnected returned True.")
        AttemptReconnect()
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorQuestProgress: State changed to NotLoggedIn. Returning 'disconnected'")
        return "disconnected"
    }
    if (IsPlayerDead()) {
        DebugLog("MonitorQuestProgress: IsPlayerDead returned True.")
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorQuestProgress: State changed to NotLoggedIn. Returning 'player_dead'")
        return "player_dead"
    }

    dialogueHandled := HandleInProgressDialogue()
    if (dialogueHandled) {
        DebugLog("MonitorQuestProgress: Handled in-progress dialogue.")
    }

    return "in_progress"
}

;———————————————————————————————————————————————————————————————
; === PVP Flow ===
ActionPVP() {
    global Bot ; Only Bot needed globally here
    DebugLog("ActionPVP: --- Entered function ---")

    opponentsVisibleResult := OpponentsVisible() ; Assumes this helper has debug logs
    DebugLog("ActionPVP: Initial OpponentsVisible check returned: '" . (opponentsVisibleResult ? "True" : "False") . "'")

    if (!opponentsVisibleResult) {
        ; Need to navigate to opponent screen
        DebugLog("ActionPVP: Opponents not visible. Navigating PVP menu...")

        pvpWindowOpen := IsPvpWindowOpen() ; Assumes this helper has debug logs
        DebugLog("ActionPVP: IsPvpWindowOpen returned: '" . (pvpWindowOpen ? "True" : "False") . "'")
        if (!pvpWindowOpen) {
            DebugLog("ActionPVP: PVP Window not open. Calling ClickPVPButton...")
            if (!ClickPVPButton()) { ; Assumes this helper logs failure and returns false
                 DebugLog("ActionPVP: ClickPVPButton failed. Returning 'retry'.")
                 return "retry"
            }
            Sleep, 600 ; Wait for window to open
             pvpWindowOpen := IsPvpWindowOpen() ; Check again
             DebugLog("ActionPVP: IsPvpWindowOpen (after click) returned: '" . (pvpWindowOpen ? "True" : "False") . "'")
             if (!pvpWindowOpen) {
                  DebugLog("ActionPVP: PVP Window still not open after click. Returning 'retry'.")
                  return "retry"
             }
             DebugLog("ActionPVP: PVP Window successfully opened.")
        } else {
             DebugLog("ActionPVP: PVP Window was already open.")
        }


        DebugLog("ActionPVP: Calling EnsureCorrectTickets(Choice: " . Bot.PvpTicketChoice . ")")
        ticketsCorrect := EnsureCorrectTickets(Bot.PvpTicketChoice) ; Assumes this helper has debug logs
         DebugLog("ActionPVP: EnsureCorrectTickets returned: '" . (ticketsCorrect ? "True" : "False") . "'")
        if (!ticketsCorrect) {
            DebugLog("ActionPVP: EnsureCorrectTickets failed. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: Tickets confirmed correct.")


        DebugLog("ActionPVP: Calling ClickPvpPlay...")
        if (!ClickPvpPlay()) { ; Assumes this helper logs failure and returns false
            DebugLog("ActionPVP: ClickPvpPlay failed. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: ClickPvpPlay succeeded.")
        Sleep, 1000 ; Wait after clicking play


        DebugLog("ActionPVP: Calling CheckOutOfResources...")
        if (CheckOutOfResources()) { ; Assumes this helper has debug logs
            DebugLog("ActionPVP: Out of resources detected after clicking Play. Returning 'outofresource'.")
            return "outofresource"
        }
        DebugLog("ActionPVP: No 'Out Of Resources' detected after clicking Play.")


        ; Re-check if opponents are visible now after clicking Play
        opponentsVisibleResult := OpponentsVisible()
        DebugLog("ActionPVP: OpponentsVisible (after Play) returned: '" . (opponentsVisibleResult ? "True" : "False") . "'")
        if (!opponentsVisibleResult) {
            DebugLog("ActionPVP: Opponents still not visible after clicking Play. Returning 'retry'.")
            return "retry"
        }
         DebugLog("ActionPVP: Opponent screen successfully reached.")

    } else {
         DebugLog("ActionPVP: Opponents were already visible.")
    }

    ; --- Opponents should be visible at this point ---

    DebugLog("ActionPVP: Calling SelectPvpOpponent (Choice: " . Bot.PvpOpponentChoice . ")")
    opponentSelected := SelectPvpOpponent(Bot.PvpOpponentChoice) ; Assumes this helper has debug logs
    DebugLog("ActionPVP: SelectPvpOpponent returned: '" . (opponentSelected ? "True" : "False") . "'")
    if (!opponentSelected) {
        DebugLog("ActionPVP: SelectPvpOpponent failed. Returning 'retry'.")
        return "retry"
    }
     DebugLog("ActionPVP: Opponent selected.")


    Sleep, 500 ; Wait after selecting opponent


    DebugLog("ActionPVP: Calling ClickPvpAccept...")
    accepted := ClickPvpAccept() ; Assumes this helper has debug logs
    DebugLog("ActionPVP: ClickPvpAccept returned: '" . (accepted ? "True" : "False") . "'")
    if (!accepted) {
         DebugLog("ActionPVP: ClickPvpAccept failed. Returning 'retry'.")
        return "retry"
    }
    DebugLog("ActionPVP: PVP Accept clicked.")


    DebugLog("ActionPVP: --- Success! All steps completed. Returning 'started'. ---")
    return "started"
}

MonitorPVPProgress() {
    global Bot
    ; Note: BotMain logs "monitoring PVP"

    actionComplete := IsActionComplete() ; Checks for Town button
    DebugLog("MonitorPVPProgress: IsActionComplete returned: '" . (actionComplete ? "True" : "False") . "'")
    if (actionComplete) {
        DebugLog("MonitorPVPProgress: PVP Complete detected. Attempting ClickTownOnComplete.")
        townClicked := ClickTownOnComplete() ; Tries to click Town button
        DebugLog("MonitorPVPProgress: ClickTownOnComplete returned: '" . (townClicked ? "True" : "False") . "'")
        if (townClicked) {
            Sleep, 800
            DebugLog("MonitorPVPProgress: Successfully clicked Town. Returning 'pvp_completed_continue'")
            return "pvp_completed_continue" ; Signal BotMain to go back to NormalOperation to loop PVP
        } else {
            DebugLog("MonitorPVPProgress: ClickTownOnComplete FAILED. Returning 'error'")
            return "error" ; Failed to click town button
        }
    }

    ; If action is not complete, check for other states:
    disconnected := IsDisconnected()
    DebugLog("MonitorPVPProgress: IsDisconnected returned: '" . (disconnected ? "True" : "False") . "'")
    if (disconnected) {
        DebugLog("MonitorPVPProgress: Disconnected detected.")
        AttemptReconnect() ; Assumes this function logs its actions
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorPVPProgress: State changed to NotLoggedIn. Returning 'disconnected'")
        return "disconnected"
    }

    playerDead := IsPlayerDead()
    DebugLog("MonitorPVPProgress: IsPlayerDead returned: '" . (playerDead ? "True" : "False") . "'")
    if (playerDead) {
        DebugLog("MonitorPVPProgress: Player Dead detected.")
        DebugLog("MonitorPVPProgress: Sending Esc to clear death screen (if possible).")
        Send, {Esc} ; Try to dismiss death screen
        Sleep, 800
        Bot.gameState := "NotLoggedIn"
        DebugLog("MonitorPVPProgress: State changed to NotLoggedIn. Returning 'player_dead'")
        return "player_dead"
    }

    ; No dialogue check needed for PVP unless specified otherwise.

    ; If we reach here, the PVP match is still running normally
    DebugLog("MonitorPVPProgress: No end/fail state detected. Returning 'in_progress'")
    return "in_progress"
}

;———————————————————————————————————————————————————————————————
; === Stub flows for other actions ===
ActionWorldBoss()   { 
    return CheckOutOfResources() ? "outofresource" : "success" 
                    }


ActionRaid()        { 
    return CheckOutOfResources() ? "outofresource" : "success"
                    }


ActionTrials()      { 
    return CheckOutOfResources() ? "outofresource" : "success"
                    }


ActionExpedition()  { 
    return CheckOutOfResources() ? "outofresource" : "success"
                    }


ActionGauntlet()    { 
    return CheckOutOfResources() ? "outofresource" : "success"
                    }

;———————————————————————————————————————————————————————————————
; === Helper functions (all reference Bot.ocr.* patterns) ===

IsMainScreenAnchor() {
    global Bot
    return FindText(X, Y, 790-150000, 579-150000, 790+150000, 579+150000, 0, 0, Bot.ocr.QuestIcon)
}

AttemptReconnect() {
    global Bot
     ; No entry/exit needed unless problematic. Log IF found.
    DebugLog("AttemptReconnect: Checking for disconnect message...")
    if FindText(X, Y, 696, 470, 2503, 1632, 0, 0, Bot.ocr.Disconnect) {
         DebugLog("AttemptReconnect: Found disconnect message. Clicking OK.")
        FindText().Click(X,Y,"L")
        Sleep, 2000
    } else {
         DebugLog("AttemptReconnect: Disconnect message not found.")
    }
}

CheckOutOfResources() {
    global Bot
    DebugLog("CheckOutOfResources: --- Entered Function ---")
    ; Ensure Bot.ocr.OutOfResources pattern is correct
    result := FindText(X, Y, 1000-150000, 800-150000, 1000+150000, 800+150000, 0, 0, Bot.ocr.OutOfResources)
    found := result ? "True" : "False"
    DebugLog("CheckOutOfResources: FindText result: " . found . " --- Exiting function ---")
    return result ; Return FindText result
}

IsQuestWindowOpen() {
    global Bot
    DebugLog("IsQuestWindowOpen: --- Entered function ---")
    ; Use a reliable element WITHIN the quest window (e.g., the Accept button is good if using wide coords)
    ; Ensure Bot.ocr.Button.Accept pattern is correct
    result := FindText(X, Y, 1045-150000, 642-150000, 1045+150000, 642+150000, 0, 0, Bot.ocr.Button.QuestWindowOpen)
    found := result ? "True" : "False" ; Convert FindText result to True/False string
    DebugLog("IsQuestWindowOpen: FindText for the zone button within quest returned: " . found)
    DebugLog("IsQuestWindowOpen: --- Exiting function ---")
    return result ; Return the original FindText result (evaluates correctly in IFs)
}

ClickQuestIcon() {
    global Bot
    DebugLog("ClickQuestIcon: --- Entered function ---")
    ; Ensure Bot.ocr.QuestIcon pattern is correct
    found := FindText(X, Y, 790-150000, 579-150000, 790+150000, 579+150000, 0, 0, Bot.ocr.QuestIcon)
    if (found) {
        DebugLog("ClickQuestIcon: Found, Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 100 ; Short sleep after click
    } else {
        DebugLog("ClickQuestIcon: Quest Icon NOT found!")
    }
    DebugLog("ClickQuestIcon: --- Exiting function ---")
    ; This function doesn't need to return anything, it just performs an action.
}

GetZoneNameFromPattern(patternToFind) {
    global Bot
    for index, patternInArray in Bot.ocr.Zone
    {
        if (patternInArray = patternToFind)
        {
            return "Zone" . index ; Return "Zone1", "Zone2" etc.
        }
    }
    return "UnknownZone" ; Return this if pattern not found in the array
}

EnsureCorrectZone(targetZonePattern) {
    global Bot
    targetZoneName := GetZoneNameFromPattern(targetZonePattern) ; Get target name for logging
    DebugLog("EnsureCorrectZone: --- Entered Function --- Target Zone: " . targetZoneName)

    attempts := 0
    currentZoneName := DetectCurrentZoneName() ; Get current name
    DebugLog("EnsureCorrectZone: Initial detected zone: '" . currentZoneName . "' (Attempt " . attempts . ")")

    ; Compare NAMES for loop condition
    while (currentZoneName != targetZoneName && attempts < 20) {
        DebugLog("EnsureCorrectZone: Mismatch! Current='" . currentZoneName . "', Target='" . targetZoneName . "'. Attempt " . attempts)

        ; --- Determine Click Direction (Needs Robust Logic) ---
        ; This requires knowing the order of zones. Assuming numerical order for now.
        ; Extract numbers from "ZoneN" strings
        currentZoneNum := SubStr(currentZoneName, 5) ; Get number part
        targetZoneNum := SubStr(targetZoneName, 5)   ; Get number part

        if (currentZoneNum is not number or targetZoneNum is not number) {
            DebugLog("EnsureCorrectZone: ERROR - Could not determine zone numbers for direction ('" . currentZoneName . "', '" . targetZoneName . "'). Clicking Right as default.")
            ClickRightArrow()
        } else if (currentZoneNum < targetZoneNum) {
             DebugLog("EnsureCorrectZone: Clicking Right Arrow.")
             ClickRightArrow()
        } else {
             DebugLog("EnsureCorrectZone: Clicking Left Arrow.")
             ClickLeftArrow()
        }
        ; --- End Direction Logic ---

        Sleep, 600           ; Increased sleep slightly
        currentZoneName := DetectCurrentZoneName() ; Detect NAME again
        attempts++
        DebugLog("EnsureCorrectZone: After arrow click & sleep, detected zone: '" . currentZoneName . "' (Attempt " . attempts . ")")

    } ; End while loop

    if (currentZoneName = targetZoneName) {
        DebugLog("EnsureCorrectZone: --- Success! Target zone '" . targetZoneName . "' reached. ---")
        return true
    } else {
        DebugLog("EnsureCorrectZone: --- Failed! Target zone '" . targetZoneName . "' NOT reached after " . attempts . " attempts. ---")
        return false
    }
}

DetectCurrentZoneName() {
    global Bot
    DebugLog("DetectCurrentZoneName: --- Entered function (searching 400,200 to 800,300) ---")
    for index, pat in Bot.ocr.Zone {
        ; Ensure these coordinates are correct for seeing the Zone Title Text
        if FindText(X, Y, 1191, 537, 1999, 700, 0, 0, pat) {
            zoneName := "Zone" . index
            DebugLog("DetectCurrentZoneName: Found " . zoneName . " --- Exiting function ---")
            return zoneName ; Return the NAME ("Zone1", "Zone2", etc.)
        }
    }
    DebugLog("DetectCurrentZoneName: No known zone pattern found! --- Exiting function ---")
    return "" ; Return empty if no known zone found
}

ClickRightArrow() {
    global Bot
    DebugLog("ClickRightArrow: Searching for right arrow (2128,891 to 2640,1378)...")
    if FindText(X, Y, 2048, 658, 2721, 1691, 0, 0, Bot.ocr.ZoneArrowRight) {
        DebugLog("ClickRightArrow: Found, Clicking.")
        FindText().Click(X,Y,"L")
    } else {
        DebugLog("ClickRightArrow: Arrow NOT found!")
    }
    Sleep, 400
}

ClickLeftArrow() {
    global Bot
     DebugLog("ClickLeftArrow: Searching for left arrow (592,742 to 1005,1383)...")
    if FindText(X, Y, 465, 716, 1021, 1448, 0, 0, Bot.ocr.ZoneArrowLeft) {
         DebugLog("ClickLeftArrow: Found, Clicking.")
        FindText().Click(X,Y,"L")
    } else {
         DebugLog("ClickLeftArrow: Arrow NOT found!")
    }
    Sleep, 400
}

EnsureCorrectDungeon(zoneName, dungeonName) { ; Takes NAMES now
    global Bot ; Still need Bot for patterns
    DebugLog("EnsureCorrectDungeon: --- Entered Function --- Zone Name: " . zoneName . ", Dungeon Name: " . dungeonName)
    foundResult := false ; Default to false

    if (!Bot.ocr.DungeonMapping.HasKey(zoneName)) {
        DebugLog("EnsureCorrectDungeon: ERROR - Zone '" . zoneName . "' not found in DungeonMapping.")
        return false ; Return simple false (0)
    }
    dungeonPatternList := Bot.ocr.DungeonMapping[zoneName]
    dungeonIndex := SubStr(dungeonName, 8)

    if (dungeonIndex is not number or dungeonIndex < 1 || dungeonIndex > dungeonPatternList.MaxIndex()) {
         DebugLog("EnsureCorrectDungeon: ERROR - Invalid dungeon index '" . dungeonIndex . "' extracted from '" . dungeonName . "'.")
         return false ; Return simple false (0)
    }

    targetDungeonPattern := dungeonPatternList[dungeonIndex]
    DebugLog("EnsureCorrectDungeon: Target Dungeon Pattern starts: " . SubStr(targetDungeonPattern, 1, 10) . "...")
    DebugLog("EnsureCorrectDungeon: Searching for pattern in region 660,496 to 2501,1680...")

    ; Perform FindText and store the result OBJECT in foundResult
    ; DO NOT use global X, Y here.
    foundResult := FindText(X, Y, 660, 496, 2501, 1680, 0, 0, targetDungeonPattern)

    if (foundResult) {
        DebugLog("EnsureCorrectDungeon: FindText result: True (Pattern Found) --- Exiting function ---")
    } else {
        DebugLog("EnsureCorrectDungeon: FindText result: False (Pattern Not Found) --- Exiting function ---")
    }
    ; Return the raw FindText result OBJECT (evaluates correctly in IFs)
    return foundResult
}

SelectHeroic() {
    global Bot
    DebugLog("SelectHeroic: --- Entered Function ---")
    ; Ensure Bot.ocr.Button.Heroic pattern is correct
    DebugLog("SelectHeroic: Searching for Heroic button...")
    heroicButton := FindText(X, Y, 2020-150000, 1033-150000, 2020+150000, 1033+150000, 0, 0, Bot.ocr.Button.Heroic)
    if (heroicButton) {
         DebugLog("SelectHeroic: Found Heroic button-Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 950
        DebugLog("SelectHeroic: Returning True. --- Exiting function ---")
        return true
    } else {
        DebugLog("SelectHeroic: Heroic button NOT found. Returning False. --- Exiting function ---")
        return false
    }
}

ClickAcceptQuest() {
    global Bot
    DebugLog("ClickAcceptQuest: --- Entered Function ---")
    acceptButtonFound := false

    ; Now look for the Accept button
     DebugLog("ClickAcceptQuest: Searching for Accept button...")
    ; Ensure Bot.ocr.Button.Accept pattern is correct
    if FindText(X, Y, 1861-150000, 1539-150000, 1861+150000, 1539+150000, 0, 0, Bot.ocr.Button.Accept) {
        acceptButtonFound := true
        DebugLog("ClickAcceptQuest: Found Accept button-Clicking.")
        FindText().Click(X,Y,"L")
        Sleep, 900
        ; Check AGAIN for OutOfResources immediately after clicking Accept, as it might pop up then
        if (CheckOutOfResources()) {
             DebugLog("ClickAcceptQuest: Out of resources detected AFTER clicking Accept. Returning 'outofresource'. --- Exiting function ---")
             return "outofresource"
        }
        DebugLog("ClickAcceptQuest: Clicked Accept, no immediate 'Out of Resources'. Returning 'confirmed'. --- Exiting function ---")
        return "confirmed"
    } else {
        DebugLog("ClickAcceptQuest: Accept button NOT found. Returning 'notfound'. --- Exiting function ---")
        return "notfound" ; Return a specific value if not found
    }
}

EnsureAutoPilotOn() {
    global Bot
    DebugLog("EnsureAutoPilotOn: --- Entered function (will try up to 3 times) ---")
    foundRed := false, foundGreen := false, variation := 0.1 ; Keep color variation

    Loop, 3 ; Try up to 3 times
    {
        DebugLog("EnsureAutoPilotOn: Attempt " . A_Index . " of 3.")

        ; 1. Check for RED (Off) button
        DebugLog("EnsureAutoPilotOn: Searching for AutoPilot RED button (Variation: " . variation . ")")
        foundRed := FindText(X, Y, 1186, 384, 3207, 1659, variation, 0, Bot.ocr.AutoPilotRed)

        if (foundRed) {
            DebugLog("EnsureAutoPilotOn: Found RED AutoPilot button. Sending {Space} to toggle ON.")
            Send, {space}
            Sleep, 300 ; Short sleep after sending key
            DebugLog("EnsureAutoPilotOn: --- Exiting function (Action Taken) ---")
            return true ; Success - Exit function immediately
        }

        ; 2. If RED wasn't found, check for GREEN (On) button
        DebugLog("EnsureAutoPilotOn: RED not found. Searching for AutoPilot GREEN button (Variation: " . variation . ")")
        foundGreen := FindText(X, Y, 2480-150000, 1060-150000, 2480+150000, 1060+150000, variation, 0, Bot.ocr.AutoPilotGreen)

        if (foundGreen) {
            DebugLog("EnsureAutoPilotOn: Found GREEN AutoPilot button (already on). --- Exiting function (State Confirmed) ---")
            return true ; Success - Exit function immediately
        }

        ; 3. If neither was found on this attempt
        DebugLog("EnsureAutoPilotOn: Attempt " . A_Index . ": Neither RED nor GREEN button found.")
        if (A_Index < 3) { ; Don't sleep after the last attempt
             DebugLog("EnsureAutoPilotOn: Sleeping 400ms before next attempt.")
             Sleep, 400
        }
    } ; End Loop

    ; If loop finishes without returning true, then it failed all attempts
    DebugLog("EnsureAutoPilotOn: Neither button found after 3 attempts. --- Exiting function (Failed) ---")
    return false
}

IsActionComplete() {
    global Bot
    DebugLog("IsActionComplete: --- Entered Function ---")
    ; Checking for "Town" button using wide coords
    result := FindText(X, Y, 1463-150000, 1563-150000, 1463+150000, 1563+150000, 0, 0, Bot.ocr.Button.Town)
    found := result ? "True" : "False"
    DebugLog("IsActionComplete: FindText for Town button returned: " . found . " --- Exiting function ---")
    return result
}

IsDisconnected() {
    global Bot
    DebugLog("IsDisconnected: --- Entered Function ---")
    ; Checking for disconnect popup in specific region
    result := FindText(X, Y, 696, 470, 2503, 1632, 0, 0, Bot.ocr.Disconnect)
     found := result ? "True" : "False"
    DebugLog("IsDisconnected: FindText for Disconnect pattern returned: " . found . " --- Exiting function ---")
    return result
}

IsPlayerDead() {
    global Bot
    DebugLog("IsPlayerDead: --- Entered Function ---")
    ; Checking for death overlay in specific region
    result := FindText(X, Y, 672, 371, 2508, 944, 0, 0, Bot.ocr.PlayerDead)
    found := result ? "True" : "False"
    DebugLog("IsPlayerDead: FindText for PlayerDead pattern returned: " . found . " --- Exiting function ---")
    return result
}

ClickRerun() {
    global Bot
    DebugLog("ClickRerun: --- Entered Function ---")
    ; Checking for "Rerun" button using wide coords
    if FindText(X, Y, 1463-150000, 1563-150000, 1463+150000, 1563+150000, 0, 0, Bot.ocr.Button.Rerun) {
        DebugLog("ClickRerun: Found Rerun button-Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 500
    } else {
         DebugLog("ClickRerun: Rerun button NOT found!")
    }
     DebugLog("ClickRerun: --- Exiting function ---")
}

ClickTownOnComplete() {
    global Bot
    DebugLog("ClickTownOnComplete: --- Entered Function ---")
    ; Checking for "Town" button using wide coords
    if FindText(X, Y, 1796-150000, 1532-150000, 1796+150000, 1532+150000, 0, 0, Bot.ocr.Button.Town) {
        DebugLog("ClickTownOnComplete: Found Town button-Clicking.")
        FindText().Click(X, Y, "L")
        Sleep, 500
        DebugLog("ClickTownOnComplete: Returning True. --- Exiting function ---")
        return true
    } else {
         DebugLog("ClickTownOnComplete: Town button NOT found! Returning False. --- Exiting function ---")
        return false
    }
}

HandleInProgressDialogue() {
    global Bot
    ; No entry/exit needed unless it becomes problematic. Just log IF found.
    ; Checking for dialogue arrow in specific region
    if FindText(X, Y, 1859, 727, 2495, 1369, 0, 0, Bot.ocr.InProgressDialogue) {
        DebugLog("HandleInProgressDialogue: Found dialogue arrow. Sending {Esc}.")
        Send, {Esc}
        Sleep, 200
        return true ; Indicate dialogue was handled
    }
    return false ; Indicate no dialogue found/handled
}

;── PVP helpers ─────────────────────────

IsPvpWindowOpen() {
    global Bot
    return FindText(X, Y, 679, 453, 2504, 1632, 0, 0, Bot.ocr.Pvp.Window)
}

ClickPVPButton() {
    global Bot
    if FindText(X, Y, 612, 466, 2495, 1646, 0, 0, Bot.ocr.Pvp.Button) {
        FindText().Click(X, Y, "L")
        Sleep, 800
        return true
    }
    return false
}

EnsureCorrectTickets(choice) { ; 'choice' is the desired number (1-5)
    global Bot, X, Y ; Need X, Y for FindText output vars
    DebugLog("EnsureCorrectTickets: --- Entered function (Desired Choice: " . choice . ") ---")

    DebugLog("EnsureCorrectTickets: PART 1 - Checking current ticket selection...")
    current := "" ; Variable to store the currently selected ticket number (1-5)
    for i, pat in Bot.ocr.Pvp.TicketSelection {
        ; Region where ticket selection text is displayed: 675, 470, 2496, 1641
        if FindText(X, Y, 581, 426, 2497, 1721, 0, 0, pat) {
            current := i ; Store the index of the pattern found
            DebugLog("EnsureCorrectTickets: Found displayed ticket pattern index " . i)
            break ; Exit loop once found
        }
    }

    if (current = choice) {
        DebugLog("EnsureCorrectTickets: Tickets already set to " . choice . ". Returning True. --- Exiting function ---")
        return true ; Already correct, EXIT HERE
    }

    if (current != "") {
        DebugLog("EnsureCorrectTickets: PART 2 - Mismatch. Current is " . current . ", desired is " . choice . ". Clicking dropdown trigger.")
    } else {
        DebugLog("EnsureCorrectTickets: PART 2 - Could not determine current selection. Attempting to click dropdown trigger anyway.")
    }
    DebugLog("EnsureCorrectTickets: Searching for dropdown trigger button...")
    ; Wide coordinates based on legacy code anchor 2030, 920 - VERIFY THIS PATTERN AND COORDS
    dropdownTriggerPattern := Bot.ocr.Pvp.TicketDropdownTrigger ; Make sure this pattern is defined in Patterns.ahk
    if (FindText(X, Y, 2030-150000, 920-150000, 2030+150000, 920+150000, 0, 0, dropdownTriggerPattern)) {
        DebugLog("EnsureCorrectTickets: Found dropdown trigger at X=" . X . " Y=" . Y . ". Clicking.")
        FindText().Click(X, Y, "L") ; Click the trigger
        Sleep, 990 ; Wait for menu to open (from legacy code)
    } else {
        DebugLog("EnsureCorrectTickets: Dropdown trigger button NOT found! Returning False. --- Exiting function ---")
        return false ; Cannot proceed if trigger isn't found
    }

    entryPattern := Bot.ocr.Pvp.TicketMenu[choice] ; Get pattern for the desired choice number from Patterns.ahk
    if (entryPattern = "") {
         DebugLog("EnsureCorrectTickets: ERROR - No pattern defined for TicketMenu choice " . choice . ". Returning False.")
         return false
    }
    DebugLog("EnsureCorrectTickets: PART 3 - Searching for menu item pattern for choice " . choice . "...")
    ; Region where dropdown menu appears (from legacy code): 905, 470, 2196, 1669 - VERIFY THIS REGION
    if (FindText(X, Y, 905, 470, 2196, 1669, 0, 0, entryPattern)) {
        DebugLog("EnsureCorrectTickets: Found menu item " . choice . " at X=" . X . " Y=" . Y . ". Clicking.")
        FindText().Click(X, Y, "L") ; Click the menu item
        Sleep, 990 ; Wait after click (from legacy code)

        ; Optional Verification Step (Recommended)
        expectedDisplayPattern := Bot.ocr.Pvp.TicketSelection[choice]
        Sleep, 300 ; Short extra sleep for UI update
        if (FindText(0, 0, 675, 470, 2496, 1641, 0, 0, expectedDisplayPattern)) {
             DebugLog("EnsureCorrectTickets: Tickets successfully changed to " . choice . " (verified). Returning True. --- Exiting function ---")
             return true
        } else {
             DebugLog("EnsureCorrectTickets: Clicked menu item " . choice . ", but verification failed! Returning False. --- Exiting function ---")
             return false
        }
    } else {
        DebugLog("EnsureCorrectTickets: FAILED to find menu item pattern for choice " . choice . ". Returning False. --- Exiting function ---")
        Send, {Esc} ; Try to close dropdown if click failed
        return false
    }
}

ClickPvpPlay() {
    global Bot
    if FindText(X, Y, 659, 464, 2503, 1629, 0, 0, Bot.ocr.Pvp.PlayButton) {
        FindText().Click(X, Y, "L")
        Sleep, 10
        Mousemove 300, 300
        Sleep, 800
        return true
    }
    return false
}

OpponentsVisible() {
    global Bot
    return FindText(X, Y, 451, 420, 2520, 1735, 0.09, 0.09, Bot.ocr.Pvp.OpponentList)
}

SelectPvpOpponent(choice) {
    global Bot
    DebugLog("SelectPvpOpponent: --- Entered function (User Choice: " . choice . ") ---")

    DebugLog("SelectPvpOpponent: Searching for opponent entries...")
    hits := FindText(0, 0, 451, 420, 2520, 1735, 0.09, 0.09, Bot.ocr.Pvp.OpponentList)

    if !(hits) {
        DebugLog("SelectPvpOpponent: No opponents found! Returning False. --- Exiting function ---")
        return false
    }
    DebugLog("SelectPvpOpponent: Found " . hits.MaxIndex() . " opponent button(s).")

    map := [3, 1, 4, 2] ; Adjust map if needed!

    if (choice < 1 || choice > map.MaxIndex()) {
         DebugLog("SelectPvpOpponent: ERROR - Invalid PvpOpponentChoice (" . choice . ") configured. Must be between 1 and " . map.MaxIndex() . ". Returning False.")
         return false
    }

    realIdx := map[choice]
    DebugLog("SelectPvpOpponent: User choice " . choice . " maps to hits index " . realIdx)

    if (!hits[realIdx]) {
         DebugLog("SelectPvpOpponent: ERROR - Mapped index " . realIdx . " does not exist in the found 'hits' array (only found " . hits.MaxIndex() . " hits). Maybe FindText failed? Returning False.")
         return false
    }

    ; Get the specific hit object to click based on the mapped index
    hitToClick := hits[realIdx]
    clickX := hitToClick.x ; Get coordinates explicitly
    clickY := hitToClick.y

    DebugLog("SelectPvpOpponent: Clicking opponent at mapped index " . realIdx . " using coordinates (X=" . clickX . " Y=" . clickY . ")")

    ; *** CHANGE: Use FindText().Click() with explicit coordinates ***
    FindText().Click(clickX, clickY, "L")
    ; *** END CHANGE ***

    Sleep, 300

    DebugLog("SelectPvpOpponent: Returning True. --- Exiting function ---")
    return true
}

ClickPvpAccept() {
    global Bot
    if FindText(X, Y, 1862-150000, 1541-150000, 1862+150000, 1541+150000, 0, 0, Bot.ocr.Pvp.AcceptButton) {
        FindText().Click(X, Y, "L")
        Sleep, 800
        return true
    }
    return false
}
F12::
{
    global Bot

    if (A_IsPaused) {
        ; --- RESUME ---
        Pause, Off, 1
        
        if (Bot.previousState != "") {
            Bot.gameState := Bot.previousState
            DebugLog("Resumed via hotkey. Restoring previous state: " . Bot.gameState)
            Bot.previousState := ""
        } else {
            Bot.gameState := "NotLoggedIn"
            DebugLog("Resumed via hotkey. No previous state; resetting to NotLoggedIn.")
        }
    }
    else {
        ; --- PAUSE ---
        Bot.previousState := Bot.gameState
        Bot.gameState := "Paused"
        DebugLog("Paused via hotkey. Previous state: " . Bot.previousState)

        Pause, On, 1
    }
    return
}
